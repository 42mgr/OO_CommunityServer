name: Build Custom OnlyOffice with Mail Module Changes

on:
  workflow_dispatch:

env:
  ONLYOFFICE_VERSION: "12.0.0"

jobs:
  download-and-prepare:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        submodules: recursive
    
    - name: Cache OnlyOffice DEB package
      id: cache-deb
      uses: actions/cache@v4
      with:
        path: onlyoffice-communityserver.deb
        key: onlyoffice-deb-${{ env.ONLYOFFICE_VERSION }}-${{ hashFiles('.github/build-scripts/download-deb.sh') }}
        restore-keys: |
          onlyoffice-deb-${{ env.ONLYOFFICE_VERSION }}-
          onlyoffice-deb-
    
    - name: Install dependencies
      run: |
        echo "Installing required tools..."
        sudo apt-get update -qq
        sudo apt-get install -y wget curl jq file dpkg-dev
        
        echo "‚úÖ All dependencies ready"
        
    - name: Check if DEB already exists
      id: check-deb
      run: |
        if [ -f "onlyoffice-communityserver.deb" ] && [ -s "onlyoffice-communityserver.deb" ]; then
          echo "deb_exists=true" >> $GITHUB_OUTPUT
          echo "‚úÖ OnlyOffice DEB file already exists"
          dpkg-deb --info onlyoffice-communityserver.deb | head -10
          echo "üì¶ Existing package size: $(ls -lh onlyoffice-communityserver.deb | awk '{print $5}')"
        else
          echo "deb_exists=false" >> $GITHUB_OUTPUT
          echo "‚ùå OnlyOffice DEB file not found or empty"
        fi
        
    - name: Download official OnlyOffice package
      if: steps.check-deb.outputs.deb_exists != 'true'
      run: |
        echo "Downloading OnlyOffice package..."
        
        if [ -f ".github/build-scripts/download-deb.sh" ]; then
          chmod +x .github/build-scripts/download-deb.sh
          sudo ./.github/build-scripts/download-deb.sh
          
          if [ -f "onlyoffice-communityserver.deb" ] && [ -s "onlyoffice-communityserver.deb" ]; then
            echo "‚úÖ Successfully downloaded OnlyOffice package"
            dpkg-deb --info onlyoffice-communityserver.deb | head -10
            echo "üì¶ Package size: $(ls -lh onlyoffice-communityserver.deb | awk '{print $5}')"
          else
            echo "‚ùå Download failed"
            exit 1
          fi
        else
          echo "‚ùå Custom download script not found"
          exit 1
        fi
        
    - name: Extract official package
      run: |
        echo "Extracting official package..."
        dpkg-deb -x onlyoffice-communityserver.deb ./official-package/
        dpkg-deb -e onlyoffice-communityserver.deb ./official-package/DEBIAN/
        
        echo "Looking for existing mail module assemblies..."
        find ./official-package -name "ASC.Mail*" -type f || echo "No ASC.Mail files found"
        
    - name: Upload extracted package
      uses: actions/upload-artifact@v4
      with:
        name: extracted-onlyoffice-package
        path: |
          onlyoffice-communityserver.deb
          official-package/
        retention-days: 1

  build-mail-module:
    needs: download-and-prepare
    runs-on: windows-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        submodules: recursive
        
    - name: Setup .NET Framework and .NET SDK
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: |
          6.0.x
          7.0.x
          
    - name: Setup MSBuild
      uses: microsoft/setup-msbuild@v2
      
    - name: Setup NuGet
      uses: nuget/setup-nuget@v2
      
    - name: Download extracted package
      uses: actions/download-artifact@v4
      with:
        name: extracted-onlyoffice-package
        
    - name: Fix ALL project references and configurations
      shell: pwsh
      run: |
        Write-Host "Fixing ALL project references and configurations..."
        
        # Find ALL .csproj files in the entire repository
        $allProjects = Get-ChildItem -Path "." -Name "*.csproj" -Recurse
        
        Write-Host "Found $($allProjects.Count) project files to fix"
        
        foreach ($proj in $allProjects) {
          Write-Host "Processing project: $proj"
          
          if (Test-Path $proj) {
            $content = Get-Content $proj -Raw
            $modified = $false
            
            # Fix 1: Add missing Release|Any CPU configuration
            if ($content -notmatch 'Release.*Any CPU') {
              Write-Host "  Adding Release|Any CPU configuration"
              
              $releaseXml = "  <PropertyGroup Condition=`"'`$(Configuration)|`$(Platform)' == 'Release|Any CPU'`">`n"
              $releaseXml += "    <OutputPath>bin\Release\</OutputPath>`n"
              $releaseXml += "    <DebugType>pdbonly</DebugType>`n"
              $releaseXml += "    <Optimize>true</Optimize>`n"
              $releaseXml += "    <PlatformTarget>AnyCPU</PlatformTarget>`n"
              $releaseXml += "    <WarningLevel>1</WarningLevel>`n"
              $releaseXml += "    <TreatWarningsAsErrors>false</TreatWarningsAsErrors>`n"
              $releaseXml += "  </PropertyGroup>"
              
              $content = $content -replace '</Project>', ($releaseXml + "`n</Project>")
              $modified = $true
            }
            
            # Fix 2: Add missing Debug|Any CPU configuration
            if ($content -notmatch 'Debug.*Any CPU') {
              Write-Host "  Adding Debug|Any CPU configuration"
              
              $debugXml = "  <PropertyGroup Condition=`"'`$(Configuration)|`$(Platform)' == 'Debug|Any CPU'`">`n"
              $debugXml += "    <OutputPath>bin\Debug\</OutputPath>`n"
              $debugXml += "    <DebugSymbols>true</DebugSymbols>`n"
              $debugXml += "    <DebugType>full</DebugType>`n"
              $debugXml += "    <Optimize>false</Optimize>`n"
              $debugXml += "    <PlatformTarget>AnyCPU</PlatformTarget>`n"
              $debugXml += "    <WarningLevel>1</WarningLevel>`n"
              $debugXml += "    <TreatWarningsAsErrors>false</TreatWarningsAsErrors>`n"
              $debugXml += "  </PropertyGroup>"
              
              $content = $content -replace '</Project>', ($debugXml + "`n</Project>")
              $modified = $true
            }
            
            if ($modified) {
              Set-Content -Path $proj -Value $content -Encoding UTF8
              Write-Host "  ‚úÖ Fixed configurations for $proj"
            } else {
              Write-Host "  ‚úÖ $proj already has proper configurations"
            }
          }
        }
        
        # Create comprehensive Directory.Build.props with global project reference settings
        $buildPropsXml = @"
        <Project>
          <PropertyGroup>
            <Platform Condition="`$(Platform) == ''">AnyCPU</Platform>
            <Configuration Condition="`$(Configuration) == ''">Release</Configuration>
            <TreatWarningsAsErrors>false</TreatWarningsAsErrors>
            <WarningLevel>1</WarningLevel>
            <OutputPath Condition="`$(OutputPath) == ''">bin\`$(Configuration)\</OutputPath>
            
            <!-- Fix for project reference resolution -->
            <ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch>None</ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch>
            <AutoGenerateBindingRedirects>true</AutoGenerateBindingRedirects>
            <GenerateBindingRedirectsOutputType>true</GenerateBindingRedirectsOutputType>
          </PropertyGroup>
          
          <!-- Default configurations for all projects -->
          <PropertyGroup Condition="'`$(Configuration)|`$(Platform)' == 'Release|AnyCPU'">
            <OutputPath>bin\Release\</OutputPath>
            <DebugType>pdbonly</DebugType>
            <Optimize>true</Optimize>
            <PlatformTarget>AnyCPU</PlatformTarget>
          </PropertyGroup>
          
          <PropertyGroup Condition="'`$(Configuration)|`$(Platform)' == 'Debug|AnyCPU'">
            <OutputPath>bin\Debug\</OutputPath>
            <DebugSymbols>true</DebugSymbols>
            <DebugType>full</DebugType>
            <Optimize>false</Optimize>
            <PlatformTarget>AnyCPU</PlatformTarget>
          </PropertyGroup>
        </Project>
        "@
        
        Set-Content -Path "Directory.Build.props" -Value $buildPropsXml -Encoding UTF8
        Write-Host "‚úÖ Created comprehensive Directory.Build.props"
        
    - name: Restore NuGet packages comprehensively
      shell: pwsh
      run: |
        Write-Host "Restoring NuGet packages comprehensively..."
        
        # Ensure we're in the right directory
        Set-Location $env:GITHUB_WORKSPACE
        Write-Host "Working directory: $(Get-Location)"
        
        # First, try to restore any solution files
        try {
          $slnFiles = Get-ChildItem -Path "." -Name "*.sln" -Recurse -ErrorAction Stop
          
          if ($slnFiles) {
            foreach ($sln in $slnFiles) {
              Write-Host "Restoring packages for solution: $sln"
              try {
                nuget restore $sln -Verbosity normal -NonInteractive -Force
                Write-Host "‚úÖ Successfully restored $sln"
              } catch {
                Write-Host "‚ö†Ô∏è Warning: Failed to restore $sln - $($_.Exception.Message)"
              }
            }
          } else {
            Write-Host "No solution files found"
          }
        } catch {
          Write-Host "‚ö†Ô∏è Error searching for solution files: $($_.Exception.Message)"
        }
        
        # Restore packages for individual projects that have packages.config
        try {
          $packagesConfigs = Get-ChildItem -Path "." -Name "packages.config" -Recurse -ErrorAction SilentlyContinue
          
          if ($packagesConfigs) {
            Write-Host "Found $($packagesConfigs.Count) packages.config files"
            
            foreach ($pkgConfig in $packagesConfigs) {
              $projectDir = Split-Path $pkgConfig -Parent
              $fullProjectDir = Resolve-Path $projectDir
              Write-Host "Restoring packages for: $fullProjectDir"
              
              try {
                Push-Location $fullProjectDir
                
                # Determine the correct packages directory relative path
                $depth = ($fullProjectDir.ToString() -split [regex]::Escape([IO.Path]::DirectorySeparatorChar)).Count - ($env:GITHUB_WORKSPACE -split [regex]::Escape([IO.Path]::DirectorySeparatorChar)).Count
                $packagesDir = "../" * $depth + "packages"
                
                Write-Host "  Using packages directory: $packagesDir"
                nuget restore packages.config -PackagesDirectory $packagesDir -Verbosity normal -Force
                Write-Host "  ‚úÖ Successfully restored packages for $($projectDir)"
                
                Pop-Location
              } catch {
                Write-Host "  ‚ö†Ô∏è Warning: Failed to restore packages for $projectDir - $($_.Exception.Message)"
                Pop-Location
              }
            }
          } else {
            Write-Host "No packages.config files found"
          }
        } catch {
          Write-Host "‚ö†Ô∏è Error searching for packages.config files: $($_.Exception.Message)"
        }
        
        # Final check - make sure we're back in the workspace
        Set-Location $env:GITHUB_WORKSPACE
        
    - name: Try solution-based build approach first
      shell: pwsh
      run: |
        Write-Host "Attempting solution-based build approach..."
        
        # Find all solution files
        $solutionFiles = Get-ChildItem -Path "." -Name "*.sln" -Recurse
        
        if ($solutionFiles) {
          Write-Host "Found $($solutionFiles.Count) solution files:"
          foreach ($sln in $solutionFiles) {
            Write-Host "  - $sln"
          }
          
          # Try building the main solution that contains the mail module
          $mainSolution = $solutionFiles | Where-Object { $_ -like "*Studio*" -or $_ -like "*Mail*" -or $_ -like "*CommunityServer*" } | Select-Object -First 1
          
          if (-not $mainSolution) {
            $mainSolution = $solutionFiles[0]
          }
          
          Write-Host "`n=== Building main solution: $mainSolution ==="
          
          try {
            # Build the solution with comprehensive settings - FIXED QUOTES
            Write-Host "Building solution with comprehensive configuration..."
            msbuild $mainSolution /p:Configuration=Release /p:Platform="Any CPU" /p:TreatWarningsAsErrors=false /p:WarningLevel=1 /p:ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch=None /p:AutoGenerateBindingRedirects=true /p:BuildProjectReferences=true /verbosity:normal /maxcpucount /nologo
              
            if ($LASTEXITCODE -eq 0) {
              Write-Host "‚úÖ Successfully built solution: $mainSolution"
            } else {
              Write-Host "‚ùå Failed to build solution: $mainSolution (exit code: $LASTEXITCODE)"
            }
          } catch {
            Write-Host "‚ùå Exception building solution: $($_.Exception.Message)"
          }
          
          # Check if our target was built
          if (Test-Path "module/ASC.Mail/ASC.Mail/bin/Release/ASC.Mail.dll") {
            Write-Host "`nüéâ SUCCESS: ASC.Mail.dll was built via solution!"
            Get-ChildItem "module/ASC.Mail/ASC.Mail/bin/Release/" | Select-Object Name, Length, LastWriteTime
          } else {
            Write-Host "`n‚ö†Ô∏è ASC.Mail.dll not found after solution build"
            
            # Check what was actually built
            Write-Host "Checking what assemblies were built..."
            $builtDlls = Get-ChildItem -Path "." -Name "*.dll" -Recurse | Where-Object { $_ -like "*bin*Release*" -or $_ -like "*bin*Debug*" }
            if ($builtDlls) {
              Write-Host "Built DLLs found:"
              $builtDlls | ForEach-Object { Write-Host "  - $_" }
            } else {
              Write-Host "No DLLs were built successfully"
            }
          }
        } else {
          Write-Host "‚ùå No solution files found!"
        }
        
    - name: Fallback - Build individual projects with dependency order
      shell: pwsh
      run: |
        Write-Host "Fallback: Building individual projects with dependency order..."
        
        # Build order: common projects first, then mail module
        $buildOrder = @(
          "common/ASC.Common/ASC.Common.csproj",
          "common/ASC.Core.Common/ASC.Core.Common.csproj", 
          "common/ASC.Data.Storage/ASC.Data.Storage.csproj",
          "web/core/ASC.Web.Core/ASC.Web.Core.csproj",
          "module/ASC.Api/ASC.Api/ASC.Api.Core.csproj",
          "module/ASC.Api/ASC.Specific/ASC.Specific.csproj",
          "module/ASC.ElasticSearch/ASC.ElasticSearch.csproj",
          "module/ASC.Mail.Server/ASC.Mail.Server/ASC.Mail.Server.csproj",
          "module/ASC.Thrdparty/ASC.FederatedLogin/ASC.FederatedLogin.csproj",
          "module/ASC.Mail/ASC.Mail/ASC.Mail.csproj"
        )
        
        $successfulBuilds = @()
        $failedBuilds = @()
        
        foreach ($project in $buildOrder) {
          if (Test-Path $project) {
            Write-Host "`n=== Building: $project ==="
            
            try {
              # FIXED: Single line with proper parameter formatting
              msbuild $project /p:Configuration=Release /p:Platform="Any CPU" /p:TreatWarningsAsErrors=false /p:WarningLevel=1 /p:ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch=None /p:AutoGenerateBindingRedirects=true /verbosity:minimal /nologo
                
              if ($LASTEXITCODE -eq 0) {
                Write-Host "‚úÖ Successfully built $project"
                $successfulBuilds += $project
              } else {
                Write-Host "‚ùå Failed to build $project (exit code: $LASTEXITCODE)"
                $failedBuilds += $project
                
                # For critical dependencies, try to continue anyway
                if ($project -like "*ASC.Common*") {
                  Write-Host "‚ö†Ô∏è Critical dependency failed, but continuing..."
                }
              }
            } catch {
              Write-Host "‚ùå Exception building $project`: $($_.Exception.Message)"
              $failedBuilds += $project
            }
          } else {
            Write-Host "‚ö†Ô∏è Project not found: $project"
          }
        }
        
        Write-Host "`n=== Build Summary ==="
        Write-Host "Successful builds ($($successfulBuilds.Count)):"
        foreach ($success in $successfulBuilds) {
          Write-Host "  ‚úÖ $success"
        }
        
        Write-Host "Failed builds ($($failedBuilds.Count)):"
        foreach ($failed in $failedBuilds) {
          Write-Host "  ‚ùå $failed"
        }
        
        # Check if our main target (ASC.Mail) was built successfully
        if (Test-Path "module/ASC.Mail/ASC.Mail/bin/Release/ASC.Mail.dll") {
          Write-Host "`nüéâ SUCCESS: ASC.Mail.dll was built!"
          Get-ChildItem "module/ASC.Mail/ASC.Mail/bin/Release/" | Select-Object Name, Length, LastWriteTime
        } else {
          Write-Host "`n‚ùå FAILED: ASC.Mail.dll was not built"
          Write-Host "Attempting verbose build of mail module..."
          
          # Try one more time with verbose output to see what's failing
          Set-Location "module/ASC.Mail/ASC.Mail"
          msbuild ASC.Mail.csproj /p:Configuration=Release /p:Platform="Any CPU" /p:TreatWarningsAsErrors=false /verbosity:detailed
          Set-Location $env:GITHUB_WORKSPACE
        }
        
    - name: Collect comprehensive build outputs
      shell: pwsh
      run: |
        Write-Host "Collecting all build outputs..."
        
        # Find all DLLs that were built
        $allBuiltDlls = Get-ChildItem -Path "." -Name "*.dll" -Recurse | Where-Object { 
          $fullPath = Resolve-Path $_
          $dir = Split-Path $fullPath -Parent
          $dir -like "*bin*Release*" -or $dir -like "*bin*Debug*"
        }
        
        Write-Host "Found $($allBuiltDlls.Count) built DLL files:"
        foreach ($dll in $allBuiltDlls) {
          $fullPath = Resolve-Path $dll
          $fileInfo = Get-Item $fullPath
          Write-Host "  üì¶ $dll - $($fileInfo.Length) bytes - $($fileInfo.LastWriteTime)"
        }
        
        # Create build report
        $buildReport = @"
        # Build Report - $(Get-Date)
        
        ## Build Summary
        - Total DLLs found: $($allBuiltDlls.Count)
        - ASC.Mail.dll built: $(Test-Path 'module/ASC.Mail/ASC.Mail/bin/Release/ASC.Mail.dll')
        
        ## Built Assemblies
        $($allBuiltDlls | ForEach-Object { "- $_" } | Out-String)
        
        ## Key Files Status
        - ASC.Mail.dll: $(if (Test-Path 'module/ASC.Mail/ASC.Mail/bin/Release/ASC.Mail.dll') { '‚úÖ FOUND' } else { '‚ùå MISSING' })
        - ASC.Common.dll: $(if (Get-ChildItem -Name 'ASC.Common.dll' -Recurse) { '‚úÖ FOUND' } else { '‚ùå MISSING' })
        - ASC.Core.Common.dll: $(if (Get-ChildItem -Name 'ASC.Core.Common.dll' -Recurse) { '‚úÖ FOUND' } else { '‚ùå MISSING' })
        "@
        
        Set-Content -Path "build-report.md" -Value $buildReport -Encoding UTF8
        
    - name: Upload build artifacts
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: built-mail-module-${{ github.run_number }}
        path: |
          module/ASC.Mail/ASC.Mail/bin/
          module/ASC.Mail/ASC.Mail/obj/
          common/*/bin/Release/*.dll
          web/*/bin/Release/*.dll
          module/*/bin/Release/*.dll
          build-report.md
        retention-days: 3

  create-custom-package:
    needs: [download-and-prepare, build-mail-module]
    runs-on: ubuntu-latest
    if: always() && needs.download-and-prepare.result == 'success'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        submodules: recursive
        
    - name: Download extracted package
      uses: actions/download-artifact@v4
      with:
        name: extracted-onlyoffice-package
        
    - name: Download build outputs
      uses: actions/download-artifact@v4
      continue-on-error: true
      with:
        name: built-mail-module-${{ github.run_number }}
        path: build-output/
        
    - name: Create custom package with comprehensive integration
      run: |
        echo "Creating custom package with mail module changes..."
        
        mkdir -p custom-package
        cp -r official-package/* custom-package/
        
        # Display build report if available
        if [ -f "build-output/build-report.md" ]; then
          echo "=== Build Report ==="
          cat build-output/build-report.md
          echo "===================="
        fi
        
        # Look for built DLLs
        echo "Looking for built assemblies..."
        find build-output/ -name "*.dll" -type f | head -20
        
        # Check if we have the main ASC.Mail.dll
        if [ -f "build-output/module/ASC.Mail/ASC.Mail/bin/Release/ASC.Mail.dll" ]; then
          echo "‚úÖ Found compiled ASC.Mail.dll - integrating into package"
          
          # Find where mail assemblies should go in the official package
          mail_bin_locations=$(find ./custom-package -name "*.dll" -path "*Mail*" -type f | head -5)
          
          if [ -n "$mail_bin_locations" ]; then
            # Get the directory where mail DLLs should be placed
            mail_bin_dir=$(dirname "$(echo "$mail_bin_locations" | head -1)")
            echo "Installing compiled mail module to: $mail_bin_dir"
            
            # Copy all built DLLs to the appropriate location
            find build-output/ -name "*.dll" -type f -exec cp {} "$mail_bin_dir/" \; 2>/dev/null || true
            
            echo "‚úÖ Integrated compiled mail module assemblies"
          else
            echo "Creating new bin directory for compiled assemblies"
            mkdir -p ./custom-package/opt/onlyoffice/CommunityServer/bin/
            find build-output/ -name "*.dll" -type f -exec cp {} ./custom-package/opt/onlyoffice/CommunityServer/bin/ \; 2>/dev/null || true
          fi
        else
          echo "‚ö†Ô∏è No compiled ASC.Mail.dll found - using source-only package"
        fi
        
        # Always include source files and documentation
        echo "Including custom source files and documentation..."
        mkdir -p ./custom-package/opt/onlyoffice/CommunityServer/custom-sources/ASC.Mail/
        
        # Copy custom source files
        for src_file in \
          "module/ASC.Mail/ASC.Mail/Utils/MailAddressHelper.cs" \
          "module/ASC.Mail/ASC.Mail/Core/DaoFactory.cs" \
          "module/ASC.Mail/ASC.Mail/Core/Engine/CrmLinkEngine.cs" \
          "module/ASC.Mail/ASC.Mail/Core/Engine/MessageEngine.cs" \
          "module/ASC.Mail/ASC.Mail/Core/Dao/CrmContactDao.cs" \
          "module/ASC.Mail/ASC.Mail/Core/Dao/Interfaces/ICrmContactDao.cs"; do
          
          if [ -f "$src_file" ]; then
            cp "$src_file" ./custom-package/opt/onlyoffice/CommunityServer/custom-sources/ASC.Mail/
            echo "‚úì Copied $(basename "$src_file")"
          else
            echo "‚ö†Ô∏è Source file not found: $src_file"
          fi
        done
        
        # Include build report
        if [ -f "build-output/build-report.md" ]; then
          cp build-output/build-report.md ./custom-package/opt/onlyoffice/CommunityServer/
        fi
        
        # Create comprehensive documentation
        cat > ./custom-package/opt/onlyoffice/CommunityServer/CUSTOM_CHANGES.md << EOF
        # Custom OnlyOffice Build
        
        **Repository:** ${{ github.repository }}
        **Commit:** ${{ github.sha }}
        **Build Number:** ${{ github.run_number }}
        **Build Date:** $(date)
        **OnlyOffice Version:** ${{ env.ONLYOFFICE_VERSION }}
        
        ## Enhanced CRM Mail Integration
        
        This package includes enhanced CRM integration for automatic email-to-contact linking.
        All incoming and outgoing emails are automatically added to CRM if contacts are found
        in the address book.
        
        ### Modified Files:
        - \`Utils/MailAddressHelper.cs\` - Enhanced email address validation and processing
        - \`Core/DaoFactory.cs\` - Extended factory for CRM contact data access
        - \`Core/Engine/CrmLinkEngine.cs\` - Automatic CRM linking engine  
        - \`Core/Engine/MessageEngine.cs\` - Enhanced message processing with CRM integration
        - \`Core/Dao/CrmContactDao.cs\` - CRM contact data access layer
        - \`Core/Dao/Interfaces/ICrmContactDao.cs\` - CRM contact DAO interface
        
        ### Package Contents:
        - **Compiled assemblies** (if build succeeded): Integrated into OnlyOffice binary directories
        - **Source files**: \`/opt/onlyoffice/CommunityServer/custom-sources/ASC.Mail/\`
        - **Build report**: \`/opt/onlyoffice/CommunityServer/build-report.md\`
        - **This documentation**: \`/opt/onlyoffice/CommunityServer/CUSTOM_CHANGES.md\`
        
        ### Installation Notes:
        1. This package can be installed like any OnlyOffice Community Server package
        2. If compiled assemblies are included, they will replace the original mail module
        3. Source files are provided for reference and potential manual compilation
        4. Check build-report.md for details on what assemblies were successfully compiled
        EOF
        
        echo "‚úÖ Custom package prepared with comprehensive mail integration"
        
    - name: Build custom Debian package
      run: |
        echo "Building custom Debian package..."
        
        # Update package metadata
        if [ -f "./custom-package/DEBIAN/control" ]; then
          # Update package name and version
          sed -i 's/Package: onlyoffice-communityserver/Package: onlyoffice-communityserver-custom/' ./custom-package/DEBIAN/control
          sed -i "s/Version: .*/Version: ${{ env.ONLYOFFICE_VERSION }}-custom-${{ github.run_number }}/" ./custom-package/DEBIAN/control
          
          # Add custom description
          sed -i '/^Description:/a \ Custom build with enhanced CRM email integration.' ./custom-package/DEBIAN/control
          sed -i '/Custom build with enhanced CRM email integration./a \ Includes automatic email-to-contact linking, enhanced mail processing,' ./custom-package/DEBIAN/control  
          sed -i '/Includes automatic email-to-contact linking, enhanced mail processing,/a \ and improved CRM integration for OnlyOffice Community Server.' ./custom-package/DEBIAN/control
        fi
        
        # Build the package
        dpkg-deb --build ./custom-package onlyoffice-communityserver-custom.deb
        
        echo "‚úÖ Custom package created successfully"
        dpkg-deb --info onlyoffice-communityserver-custom.deb
        echo "üì¶ Package size: $(ls -lh onlyoffice-communityserver-custom.deb | awk '{print $5}')"
        
    - name: Upload custom package
      uses: actions/upload-artifact@v4
      with:
        name: onlyoffice-custom-${{ github.run_number }}
        path: onlyoffice-communityserver-custom.deb
        retention-days: 30

  build-docker:
    needs: create-custom-package
    runs-on: ubuntu-latest
    if: needs.create-custom-package.result == 'success'
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
    
    - name: Download custom package
      uses: actions/download-artifact@v4
      with:
        name: onlyoffice-custom-${{ github.run_number }}
        
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      
    - name: Build Docker image
      run: |
        cat > Dockerfile << 'EOF'
        FROM ubuntu:20.04
        
        ENV DEBIAN_FRONTEND=noninteractive
        
        # Install dependencies
        RUN apt-get update && \
            apt-get install -y \
            wget curl apt-transport-https ca-certificates gnupg lsb-release \
            supervisor nginx mysql-client postgresql-client && \
            rm -rf /var/lib/apt/lists/*
            
        # Install .NET runtime
        RUN wget https://packages.microsoft.com/config/ubuntu/20.04/packages-microsoft-prod.deb -O packages-microsoft-prod.deb && \
            dpkg -i packages-microsoft-prod.deb && \
            apt-get update && \
            apt-get install -y dotnet-runtime-6.0 && \
            rm packages-microsoft-prod.deb && \
            rm -rf /var/lib/apt/lists/*
        
        # Install custom OnlyOffice package  
        COPY onlyoffice-communityserver-custom.deb /tmp/
        RUN dpkg -i /tmp/onlyoffice-communityserver-custom.deb || apt-get install -f -y && \
            rm /tmp/onlyoffice-communityserver-custom.deb
        
        # Add identification labels
        LABEL org.opencontainers.image.title="OnlyOffice Community Server - Enhanced CRM Mail Integration"
        LABEL org.opencontainers.image.description="OnlyOffice with automatic email-to-contact linking and enhanced CRM integration"
        LABEL org.opencontainers.image.source="${{ github.server_url }}/${{ github.repository }}"
        LABEL org.opencontainers.image.revision="${{ github.sha }}"
        LABEL org.opencontainers.image.version="${{ env.ONLYOFFICE_VERSION }}-custom-${{ github.run_number }}"
        LABEL maintainer="Custom Build from ${{ github.repository }}"
        
        EXPOSE 80 443 5222 9865 9888
        
        HEALTHCHECK --interval=30s --timeout=10s --start-period=120s \
          CMD curl -f http://localhost/ || exit 1
          
        CMD ["/usr/bin/supervisord", "-c", "/etc/supervisor/supervisord.conf"]
        EOF
        
        docker build -t onlyoffice-custom-mail:${{ github.run_number }} .
        docker tag onlyoffice-custom-mail:${{ github.run_number }} onlyoffice-custom-mail:latest
        
        # Save the image
        docker save onlyoffice-custom-mail:latest | gzip > onlyoffice-custom-mail-image.tar.gz
        
        echo "‚úÖ Docker image built and saved"
        echo "üì¶ Image size: $(ls -lh onlyoffice-custom-mail-image.tar.gz | awk '{print $5}')"
        
    - name: Upload Docker image
      uses: actions/upload-artifact@v4
      with:
        name: onlyoffice-custom-mail-image-${{ github.run_number }}
        path: onlyoffice-custom-mail-image.tar.gz
        retention-days: 7
