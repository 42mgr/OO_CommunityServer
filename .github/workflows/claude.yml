name: Build Custom OnlyOffice with Mail Module Changes

on:
  workflow_dispatch:

env:
  ONLYOFFICE_VERSION: "12.0.0"

jobs:
  download-and-prepare:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        submodules: recursive
    
    - name: Cache OnlyOffice DEB package
      id: cache-deb
      uses: actions/cache@v4
      with:
        path: onlyoffice-communityserver.deb
        key: onlyoffice-deb-${{ env.ONLYOFFICE_VERSION }}-${{ hashFiles('.github/build-scripts/download-deb.sh') }}
        restore-keys: |
          onlyoffice-deb-${{ env.ONLYOFFICE_VERSION }}-
          onlyoffice-deb-
    
    - name: Cache extracted OnlyOffice package
      id: cache-extracted
      uses: actions/cache@v4
      with:
        path: |
          official-package/
        key: onlyoffice-extracted-${{ env.ONLYOFFICE_VERSION }}-${{ hashFiles('onlyoffice-communityserver.deb') }}
        restore-keys: |
          onlyoffice-extracted-${{ env.ONLYOFFICE_VERSION }}-
    
    - name: Install dependencies
      run: |
        echo "Installing required tools..."
        sudo apt-get update -qq
        sudo apt-get install -y wget curl jq file dpkg-dev
        
        echo "✅ All dependencies ready"
        
    - name: Check cache status and download if needed
      id: check-status
      run: |
        echo "=== CACHE STATUS CHECK ==="
        
        # Check DEB package status
        if [ -f "onlyoffice-communityserver.deb" ] && [ -s "onlyoffice-communityserver.deb" ]; then
          echo "deb_exists=true" >> $GITHUB_OUTPUT
          echo "✅ OnlyOffice DEB file exists in cache"
          dpkg-deb --info onlyoffice-communityserver.deb | head -10
          echo "📦 DEB package size: $(ls -lh onlyoffice-communityserver.deb | awk '{print $5}')"
        else
          echo "deb_exists=false" >> $GITHUB_OUTPUT
          echo "❌ OnlyOffice DEB file not found or empty"
        fi
        
        # Check extracted package status
        if [ -d "official-package" ] && [ "$(find official-package -type f | wc -l)" -gt 10 ]; then
          echo "extracted_exists=true" >> $GITHUB_OUTPUT
          echo "✅ Extracted package exists in cache"
          echo "📁 Extracted files count: $(find official-package -type f | wc -l)"
          echo "📁 Extracted package size: $(du -sh official-package | cut -f1)"
        else
          echo "extracted_exists=false" >> $GITHUB_OUTPUT
          echo "❌ Extracted package not found or incomplete"
        fi
        
    - name: Download official OnlyOffice package
      if: steps.check-status.outputs.deb_exists != 'true'
      run: |
        echo "Downloading OnlyOffice package..."
        
        if [ -f ".github/build-scripts/download-deb.sh" ]; then
          chmod +x .github/build-scripts/download-deb.sh
          sudo ./.github/build-scripts/download-deb.sh
          
          if [ -f "onlyoffice-communityserver.deb" ] && [ -s "onlyoffice-communityserver.deb" ]; then
            echo "✅ Successfully downloaded OnlyOffice package"
            dpkg-deb --info onlyoffice-communityserver.deb | head -10
            echo "📦 Package size: $(ls -lh onlyoffice-communityserver.deb | awk '{print $5}')"
          else
            echo "❌ Download failed"
            exit 1
          fi
        else
          echo "❌ Custom download script not found"
          exit 1
        fi
        
    - name: Extract official package
      if: steps.check-status.outputs.extracted_exists != 'true'
      run: |
        echo "Extracting official package..."
        
        # Ensure we have the DEB file before extracting
        if [ ! -f "onlyoffice-communityserver.deb" ] || [ ! -s "onlyoffice-communityserver.deb" ]; then
          echo "❌ DEB file not available for extraction"
          exit 1
        fi
        
        # Clean any partial extraction
        rm -rf official-package/
        
        # Extract the package
        echo "Extracting DEB contents..."
        dpkg-deb -x onlyoffice-communityserver.deb ./official-package/
        
        echo "Extracting DEB control information..."
        dpkg-deb -e onlyoffice-communityserver.deb ./official-package/DEBIAN/
        
        # Verify extraction
        extracted_files=$(find ./official-package -type f | wc -l)
        extracted_size=$(du -sh ./official-package | cut -f1)
        
        echo "✅ Extraction completed"
        echo "📁 Extracted $extracted_files files"
        echo "📁 Total extracted size: $extracted_size"
        
        echo "Looking for existing mail module assemblies..."
        find ./official-package -name "ASC.Mail*" -type f || echo "No ASC.Mail files found"
        
    - name: Verify final package state
      run: |
        echo "=== FINAL PACKAGE VERIFICATION ==="
        
        # Verify DEB package
        if [ -f "onlyoffice-communityserver.deb" ] && [ -s "onlyoffice-communityserver.deb" ]; then
          echo "✅ DEB package ready"
          echo "   Size: $(ls -lh onlyoffice-communityserver.deb | awk '{print $5}')"
        else
          echo "❌ DEB package missing or empty"
          exit 1
        fi
        
        # Verify extracted package
        if [ -d "official-package" ]; then
          extracted_files=$(find official-package -type f | wc -l)
          extracted_size=$(du -sh official-package | cut -f1)
          
          if [ "$extracted_files" -gt 10 ]; then
            echo "✅ Extracted package ready"
            echo "   Files: $extracted_files"
            echo "   Size: $extracted_size"
            
            # Show key directories
            echo "📂 Key package structure:"
            find official-package -maxdepth 3 -type d | head -10 | sed 's/^/   /'
          else
            echo "❌ Extracted package appears incomplete ($extracted_files files)"
            exit 1
          fi
        else
          echo "❌ Extracted package directory missing"
          exit 1
        fi
        
    - name: Upload package artifacts
      uses: actions/upload-artifact@v4
      with:
        name: extracted-onlyoffice-package
        path: |
          onlyoffice-communityserver.deb
          official-package/
        retention-days: 1

  build-mail-module:
    needs: download-and-prepare
    runs-on: windows-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        submodules: recursive
        
    - name: Setup .NET Framework and .NET SDK
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: |
          6.0.x
          7.0.x
          
    - name: Setup MSBuild
      uses: microsoft/setup-msbuild@v2
      
    - name: Setup NuGet
      uses: nuget/setup-nuget@v2
      
    - name: Cache NuGet packages
      id: cache-nuget
      uses: actions/cache@v4
      with:
        path: |
          ~/.nuget/packages
          packages/
        key: nuget-packages-${{ runner.os }}-${{ hashFiles('**/packages.config', '**/*.csproj') }}
        restore-keys: |
          nuget-packages-${{ runner.os }}-
          
    - name: Cache build outputs
      id: cache-build
      uses: actions/cache@v4
      with:
        path: |
          **/bin/Release/
          **/obj/Release/
        key: build-output-${{ runner.os }}-${{ github.sha }}-${{ hashFiles('**/*.cs', '**/*.csproj') }}
        restore-keys: |
          build-output-${{ runner.os }}-${{ github.sha }}-
          build-output-${{ runner.os }}-
        
    - name: Download extracted package
      uses: actions/download-artifact@v4
      with:
        name: extracted-onlyoffice-package
        
    - name: Check build cache status
      id: build-status
      shell: pwsh
      run: |
        Write-Host "=== BUILD CACHE STATUS ==="
        
        # Check if ASC.Mail.dll already exists from cache
        if (Test-Path "module/ASC.Mail/ASC.Mail/bin/Release/ASC.Mail.dll") {
          Write-Host "✅ ASC.Mail.dll found in cache!"
          $dll = Get-Item "module/ASC.Mail/ASC.Mail/bin/Release/ASC.Mail.dll"
          Write-Host "   Size: $($dll.Length) bytes"
          Write-Host "   Modified: $($dll.LastWriteTime)"
          echo "build_needed=false" >> $env:GITHUB_OUTPUT
        } else {
          Write-Host "❌ Build artifacts not found in cache, build needed"
          echo "build_needed=true" >> $env:GITHUB_OUTPUT
        }
        
        # Check NuGet package cache status
        if (Test-Path "packages") {
          $packageCount = (Get-ChildItem "packages" -Recurse -File | Measure-Object).Count
          Write-Host "✅ Found $packageCount NuGet package files in cache"
          echo "nuget_cached=true" >> $env:GITHUB_OUTPUT
        } else {
          Write-Host "❌ NuGet packages not found in cache"
          echo "nuget_cached=false" >> $env:GITHUB_OUTPUT
        }
        
    - name: Fix ALL project reference metadata systematically
      shell: pwsh
      run: |
        Write-Host "=== COMPREHENSIVE PROJECT REFERENCE METADATA FIX ==="
        Write-Host "This will fix ALL MSB3107 errors across the entire solution"
        
        # Find ALL .csproj files in the repository
        $allProjects = Get-ChildItem -Path "." -Name "*.csproj" -Recurse
        Write-Host "Found $($allProjects.Count) project files to fix"
        
        # Create a mapping of project names to GUIDs for consistency
        $projectGuids = @{}
        
        # Function to generate deterministic GUID from project name - FIXED VERSION
        function Get-DeterministicGuid($projectName) {
          if ($script:projectGuids.ContainsKey($projectName)) {
            return $script:projectGuids[$projectName]
          }
          
          # Generate a deterministic GUID based on project name
          $guidSeed = $projectName.ToLower()
          $hash = [System.Security.Cryptography.SHA1]::Create().ComputeHash([System.Text.Encoding]::UTF8.GetBytes($guidSeed))
          
          # Take only the first 16 bytes from the 20-byte SHA1 hash for GUID
          $guidBytes = $hash[0..15]
          
          # Set version and variant bits for a valid GUID
          $guidBytes[6] = ($guidBytes[6] -band 0x0F) -bor 0x50  # Version 5
          $guidBytes[8] = ($guidBytes[8] -band 0x3F) -bor 0x80  # Variant
          
          # Create GUID from the 16-byte array
          $guid = [System.Guid]::new($guidBytes)
          
          $script:projectGuids[$projectName] = $guid.ToString().ToUpper()
          return $script:projectGuids[$projectName]
        }
        
        # Alternative simpler GUID generation function if the above still fails
        function Get-SimpleGuid($projectName) {
          if ($script:projectGuids.ContainsKey($projectName)) {
            return $script:projectGuids[$projectName]
          }
          
          # Create a simple deterministic GUID based on project name hash
          $hash = $projectName.GetHashCode()
          $guidString = "{0:X8}-{1:X4}-{2:X4}-{3:X4}-{4:X12}" -f `
            ($hash -band 0xFFFFFFFF), `
            (($hash -shr 16) -band 0xFFFF), `
            (4000 + ($hash -band 0x0FFF)), `
            (0x8000 + (($hash -shr 8) -band 0x3FFF)), `
            ([Math]::Abs($projectName.GetHashCode()) % 0xFFFFFFFFFFFF)
          
          $script:projectGuids[$projectName] = $guidString
          return $script:projectGuids[$projectName]
        }
        
        # First pass: collect all project names and generate GUIDs
        Write-Host "`nFirst pass: Collecting project names and generating GUIDs..."
        foreach ($proj in $allProjects) {
          $projectName = [System.IO.Path]::GetFileNameWithoutExtension($proj)
          try {
            $guid = Get-DeterministicGuid $projectName
            Write-Host "  $projectName -> {$guid}"
          } catch {
            Write-Host "  Warning: Complex GUID generation failed for $projectName, using simple method"
            $guid = Get-SimpleGuid $projectName
            Write-Host "  $projectName -> {$guid} (simple)"
          }
        }
        
        # Second pass: fix all project reference metadata
        Write-Host "`nSecond pass: Fixing project reference metadata..."
        $totalFixed = 0
        
        foreach ($proj in $allProjects) {
          Write-Host "`nProcessing: $proj"
          
          if (Test-Path $proj) {
            $content = Get-Content $proj -Raw
            $originalContent = $content
            
            # Find all ProjectReference elements - improved regex
            $projectRefPattern = '<ProjectReference\s+Include="([^"]+)"[^>]*?(?:\s*/>|>(.*?)</ProjectReference>)'
            $projectRefs = [regex]::Matches($content, $projectRefPattern, [System.Text.RegularExpressions.RegexOptions]::Singleline)
            
            if ($projectRefs.Count -gt 0) {
              Write-Host "  Found $($projectRefs.Count) project references to fix"
              
              foreach ($match in $projectRefs) {
                $fullMatch = $match.Value
                $includePath = $match.Groups[1].Value
                $innerContent = if ($match.Groups[2].Success) { $match.Groups[2].Value } else { "" }
                
                # Extract project name from include path
                $referencedProjectName = [System.IO.Path]::GetFileNameWithoutExtension($includePath)
                
                # Check if this reference already has proper metadata
                if (-not $innerContent.Contains('<Project>') -or -not $innerContent.Contains('<n>')) {
                  Write-Host "    Fixing reference to: $referencedProjectName"
                  
                  # Get the GUID for this project
                  try {
                    $guid = Get-DeterministicGuid $referencedProjectName
                  } catch {
                    $guid = Get-SimpleGuid $referencedProjectName
                  }
                  
                  # Create proper ProjectReference with metadata
                  $newProjectRef = "<ProjectReference Include=`"$includePath`">`n"
                  $newProjectRef += "      <Project>{$guid}</Project>`n"
                  $newProjectRef += "      <n>$referencedProjectName</n>`n"
                  $newProjectRef += "    </ProjectReference>"
                  
                  # Replace the old reference
                  $content = $content -replace [regex]::Escape($fullMatch), $newProjectRef
                  $totalFixed++
                  Write-Host "      Added metadata: {$guid}"
                } else {
                  Write-Host "    Reference to $referencedProjectName already has metadata"
                }
              }
              
              # Save the file if it was modified
              if ($content -ne $originalContent) {
                Set-Content -Path $proj -Value $content -Encoding UTF8
                Write-Host "  ✅ Updated $proj"
              } else {
                Write-Host "  ✅ $proj already properly configured"
              }
            } else {
              Write-Host "  No project references found"
            }
          }
        }
        
        Write-Host "`n=== PROJECT REFERENCE FIX SUMMARY ==="
        Write-Host "✅ Processed $($allProjects.Count) project files"
        Write-Host "✅ Fixed $totalFixed project references"
        Write-Host "✅ Generated $($projectGuids.Count) unique project GUIDs"
        
        # Create a comprehensive Directory.Build.props to prevent future issues
        $buildPropsXml = @"
        <Project>
          <PropertyGroup>
            <!-- Global defaults to prevent MSB3107 errors -->
            <Platform Condition="`$(Platform) == ''">AnyCPU</Platform>
            <Configuration Condition="`$(Configuration) == ''">Release</Configuration>
            <TreatWarningsAsErrors>false</TreatWarningsAsErrors>
            <WarningLevel>1</WarningLevel>
            <OutputPath Condition="`$(OutputPath) == ''">bin\`$(Configuration)\</OutputPath>
            
            <!-- Project reference resolution fixes -->
            <ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch>None</ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch>
            <AutoGenerateBindingRedirects>true</AutoGenerateBindingRedirects>
            <GenerateBindingRedirectsOutputType>true</GenerateBindingRedirectsOutputType>
            
            <!-- Additional MSBuild settings to improve reliability -->
            <BuildProjectReferences>true</BuildProjectReferences>
            <ResolveNuGetPackages>true</ResolveNuGetPackages>
            <RestorePackages>true</RestorePackages>
          </PropertyGroup>
          
          <!-- Standard configurations for all projects -->
          <PropertyGroup Condition="'`$(Configuration)|`$(Platform)' == 'Release|AnyCPU'">
            <OutputPath>bin\Release\</OutputPath>
            <DebugType>pdbonly</DebugType>
            <Optimize>true</Optimize>
            <PlatformTarget>AnyCPU</PlatformTarget>
            <DefineConstants>TRACE</DefineConstants>
          </PropertyGroup>
          
          <PropertyGroup Condition="'`$(Configuration)|`$(Platform)' == 'Debug|AnyCPU'">
            <OutputPath>bin\Debug\</OutputPath>
            <DebugSymbols>true</DebugSymbols>
            <DebugType>full</DebugType>
            <Optimize>false</Optimize>
            <PlatformTarget>AnyCPU</PlatformTarget>
            <DefineConstants>DEBUG;TRACE</DefineConstants>
          </PropertyGroup>
          
          <!-- Ensure all projects have these configurations -->
          <PropertyGroup Condition="'`$(Configuration)|`$(Platform)' == 'Release|Any CPU'">
            <OutputPath>bin\Release\</OutputPath>
            <DebugType>pdbonly</DebugType>
            <Optimize>true</Optimize>
            <PlatformTarget>AnyCPU</PlatformTarget>
            <DefineConstants>TRACE</DefineConstants>
          </PropertyGroup>
          
          <PropertyGroup Condition="'`$(Configuration)|`$(Platform)' == 'Debug|Any CPU'">
            <OutputPath>bin\Debug\</OutputPath>
            <DebugSymbols>true</DebugSymbols>
            <DebugType>full</DebugType>
            <Optimize>false</Optimize>
            <PlatformTarget>AnyCPU</PlatformTarget>
            <DefineConstants>DEBUG;TRACE</DefineConstants>
          </PropertyGroup>
        </Project>
        "@
        
        Set-Content -Path "Directory.Build.props" -Value $buildPropsXml -Encoding UTF8
        Write-Host "✅ Created comprehensive Directory.Build.props"
        
        # Output the project GUID mapping for reference
        Write-Host "`n=== PROJECT GUID MAPPING ==="
        $projectGuids.GetEnumerator() | Sort-Object Name | ForEach-Object {
          Write-Host "  $($_.Key) = {$($_.Value)}"
        }
        
        Write-Host "`n🎉 All project reference metadata has been fixed!"
        Write-Host "This should resolve ALL MSB3107 errors across the solution."

    - name: Restore NuGet packages (only if not cached)
      if: steps.build-status.outputs.build_needed == 'true' && steps.build-status.outputs.nuget_cached != 'true'
      shell: pwsh
      run: |
        Write-Host "Restoring NuGet packages..."
        
        # Restore solution packages
        $slnFiles = Get-ChildItem -Path "." -Name "*.sln" -Recurse
        
        if ($slnFiles) {
          foreach ($sln in $slnFiles) {
            Write-Host "Restoring packages for solution: $sln"
            try {
              nuget restore $sln -Verbosity normal -NonInteractive -Force
              Write-Host "✅ Successfully restored $sln"
            } catch {
              Write-Host "⚠️ Warning: Failed to restore $sln"
            }
          }
        }
        
        # Restore individual packages.config files
        $packagesConfigs = Get-ChildItem -Path "." -Name "packages.config" -Recurse
        
        if ($packagesConfigs) {
          Write-Host "Found $($packagesConfigs.Count) packages.config files"
          
          foreach ($pkgConfig in $packagesConfigs) {
            $projectDir = Split-Path $pkgConfig -Parent
            try {
              Push-Location $projectDir
              $depth = ($projectDir -split [regex]::Escape([IO.Path]::DirectorySeparatorChar)).Count - ($env:GITHUB_WORKSPACE -split [regex]::Escape([IO.Path]::DirectorySeparatorChar)).Count
              $packagesDir = "../" * $depth + "packages"
              nuget restore packages.config -PackagesDirectory $packagesDir -Verbosity normal -Force
              Pop-Location
            } catch {
              Write-Host "⚠️ Warning: Failed to restore packages for $projectDir"
              Pop-Location
            }
          }
        }
        
    - name: Build solution (only if needed)
      if: steps.build-status.outputs.build_needed == 'true'
      shell: pwsh
      run: |
        Write-Host "=== BUILDING SOLUTION ==="
        
        # Find solution files
        $solutionFiles = Get-ChildItem -Path "." -Name "*.sln" -Recurse
        
        if ($solutionFiles) {
          # Use the Studio.sln which seems to be the main solution
          $mainSolution = $solutionFiles | Where-Object { $_ -like "*Studio*" } | Select-Object -First 1
          
          if (-not $mainSolution) {
            $mainSolution = $solutionFiles[0]
          }
          
          Write-Host "Building solution: $mainSolution"
          
          try {
            msbuild $mainSolution /p:Configuration=Release /p:Platform="Any CPU" /p:TreatWarningsAsErrors=false /p:WarningLevel=1 /p:ResolveAssemblyWarnOrErrorOnTargetArchitectureMismatch=None /p:AutoGenerateBindingRedirects=true /p:BuildProjectReferences=true /verbosity:normal /maxcpucount /nologo
            
            if ($LASTEXITCODE -eq 0) {
              Write-Host "🎉 SUCCESS: Solution built without errors!"
            } else {
              Write-Host "⚠️ Build completed with exit code: $LASTEXITCODE"
            }
          } catch {
            Write-Host "❌ Exception during build: $($_.Exception.Message)"
          }
        }
        
    - name: Verify build results
      shell: pwsh
      run: |
        Write-Host "=== BUILD RESULTS VERIFICATION ==="
        
        # Check if mail module was built
        if (Test-Path "module/ASC.Mail/ASC.Mail/bin/Release/ASC.Mail.dll") {
          Write-Host "✅ ASC.Mail.dll was built successfully!"
          $mailDll = Get-Item "module/ASC.Mail/ASC.Mail/bin/Release/ASC.Mail.dll"
          Write-Host "   Size: $($mailDll.Length) bytes"
          Write-Host "   Modified: $($mailDll.LastWriteTime)"
        } else {
          Write-Host "❌ ASC.Mail.dll not found"
        }
        
        # Count total built DLLs
        $allBuiltDlls = Get-ChildItem -Path "." -Name "*.dll" -Recurse | Where-Object { 
          $fullPath = Resolve-Path $_
          $dir = Split-Path $fullPath -Parent
          $dir -like "*bin*Release*"
        }
        
        Write-Host "📊 Total assemblies built: $($allBuiltDlls.Count)"
        
        # Create build report
        $buildReport = @"
        # Build Report - $(Get-Date)
        
        ## Build Summary
        - Total DLLs found: $($allBuiltDlls.Count)
        - ASC.Mail.dll built: $(Test-Path 'module/ASC.Mail/ASC.Mail/bin/Release/ASC.Mail.dll')
        - Build from cache: $('${{ steps.build-status.outputs.build_needed }}' -eq 'false')
        - NuGet from cache: $('${{ steps.build-status.outputs.nuget_cached }}' -eq 'true')
        
        ## Built Assemblies
        $($allBuiltDlls | ForEach-Object { "- $_" } | Out-String)
        "@
        
        Set-Content -Path "build-report.md" -Value $buildReport -Encoding UTF8
        
    - name: Upload build artifacts
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: built-mail-module-${{ github.run_number }}
        path: |
          module/ASC.Mail/ASC.Mail/bin/
          module/ASC.Mail/ASC.Mail/obj/
          common/*/bin/Release/*.dll
          web/*/bin/Release/*.dll
          module/*/bin/Release/*.dll
          build-report.md
        retention-days: 3

  create-custom-package:
    needs: [download-and-prepare, build-mail-module]
    runs-on: ubuntu-latest
    if: always() && needs.download-and-prepare.result == 'success'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        submodules: recursive
        
    - name: Download extracted package
      uses: actions/download-artifact@v4
      with:
        name: extracted-onlyoffice-package
        
    - name: Download build outputs
      uses: actions/download-artifact@v4
      continue-on-error: true
      with:
        name: built-mail-module-${{ github.run_number }}
        path: build-output/
        
    - name: Create custom package with comprehensive integration
      run: |
        echo "Creating custom package with mail module changes..."
        
        mkdir -p custom-package
        cp -r official-package/* custom-package/
        
        # Display build report if available
        if [ -f "build-output/build-report.md" ]; then
          echo "=== Build Report ==="
          cat build-output/build-report.md
          echo "===================="
        fi
        
        # Look for built DLLs
        echo "Looking for built assemblies..."
        find build-output/ -name "*.dll" -type f | head -20
        
        # Check if we have the main ASC.Mail.dll
        if [ -f "build-output/module/ASC.Mail/ASC.Mail/bin/Release/ASC.Mail.dll" ]; then
          echo "✅ Found compiled ASC.Mail.dll - integrating into package"
          
          # Find where mail assemblies should go in the official package
          mail_bin_locations=$(find ./custom-package -name "*.dll" -path "*Mail*" -type f | head -5)
          
          if [ -n "$mail_bin_locations" ]; then
            # Get the directory where mail DLLs should be placed
            mail_bin_dir=$(dirname "$(echo "$mail_bin_locations" | head -1)")
            echo "Installing compiled mail module to: $mail_bin_dir"
            
            # Copy all built DLLs to the appropriate location
            find build-output/ -name "*.dll" -type f -exec cp {} "$mail_bin_dir/" \; 2>/dev/null || true
            
            echo "✅ Integrated compiled mail module assemblies"
          else
            echo "Creating new bin directory for compiled assemblies"
            mkdir -p ./custom-package/opt/onlyoffice/CommunityServer/bin/
            find build-output/ -name "*.dll" -type f -exec cp {} ./custom-package/opt/onlyoffice/CommunityServer/bin/ \; 2>/dev/null || true
          fi
        else
          echo "⚠️ No compiled ASC.Mail.dll found - using source-only package"
        fi
        
        # Always include source files and documentation
        echo "Including custom source files and documentation..."
        mkdir -p ./custom-package/opt/onlyoffice/CommunityServer/custom-sources/ASC.Mail/
        
        # Copy custom source files
        for src_file in \
          "module/ASC.Mail/ASC.Mail/Utils/MailAddressHelper.cs" \
          "module/ASC.Mail/ASC.Mail/Core/DaoFactory.cs" \
          "module/ASC.Mail/ASC.Mail/Core/Engine/CrmLinkEngine.cs" \
          "module/ASC.Mail/ASC.Mail/Core/Engine/MessageEngine.cs" \
          "module/ASC.Mail/ASC.Mail/Core/Dao/CrmContactDao.cs" \
          "module/ASC.Mail/ASC.Mail/Core/Dao/Interfaces/ICrmContactDao.cs"; do
          
          if [ -f "$src_file" ]; then
            cp "$src_file" ./custom-package/opt/onlyoffice/CommunityServer/custom-sources/ASC.Mail/
            echo "✓ Copied $(basename "$src_file")"
          else
            echo "⚠️ Source file not found: $src_file"
          fi
        done
        
        # Include build report
        if [ -f "build-output/build-report.md" ]; then
          cp build-output/build-report.md ./custom-package/opt/onlyoffice/CommunityServer/
        fi
        
        # Create comprehensive documentation
        cat > ./custom-package/opt/onlyoffice/CommunityServer/CUSTOM_CHANGES.md << EOF
        # Custom OnlyOffice Build
        
        **Repository:** ${{ github.repository }}
        **Commit:** ${{ github.sha }}
        **Build Number:** ${{ github.run_number }}
        **Build Date:** $(date)
        **OnlyOffice Version:** ${{ env.ONLYOFFICE_VERSION }}
        
        ## Enhanced CRM Mail Integration
        
        This package includes enhanced CRM integration for automatic email-to-contact linking.
        All incoming and outgoing emails are automatically added to CRM if contacts are found
        in the address book.
        
        ### Modified Files:
        - \`Utils/MailAddressHelper.cs\` - Enhanced email address validation and processing
        - \`Core/DaoFactory.cs\` - Extended factory for CRM contact data access
        - \`Core/Engine/CrmLinkEngine.cs\` - Automatic CRM linking engine  
        - \`Core/Engine/MessageEngine.cs\` - Enhanced message processing with CRM integration
        - \`Core/Dao/CrmContactDao.cs\` - CRM contact data access layer
        - \`Core/Dao/Interfaces/ICrmContactDao.cs\` - CRM contact DAO interface
        
        ### Package Contents:
        - **Compiled assemblies** (if build succeeded): Integrated into OnlyOffice binary directories
        - **Source files**: \`/opt/onlyoffice/CommunityServer/custom-sources/ASC.Mail/\`
        - **Build report**: \`/opt/onlyoffice/CommunityServer/build-report.md\`
        - **This documentation**: \`/opt/onlyoffice/CommunityServer/CUSTOM_CHANGES.md\`
        
        ### Installation Notes:
        1. This package can be installed like any OnlyOffice Community Server package
        2. If compiled assemblies are included, they will replace the original mail module
        3. Source files are provided for reference and potential manual compilation
        4. Check build-report.md for details on what assemblies were successfully compiled
        EOF
        
        echo "✅ Custom package prepared with comprehensive mail integration"
        
    - name: Build custom Debian package
      run: |
        echo "Building custom Debian package..."
        
        # Update package metadata
        if [ -f "./custom-package/DEBIAN/control" ]; then
          # Update package name and version
          sed -i 's/Package: onlyoffice-communityserver/Package: onlyoffice-communityserver-custom/' ./custom-package/DEBIAN/control
          sed -i "s/Version: .*/Version: ${{ env.ONLYOFFICE_VERSION }}-custom-${{ github.run_number }}/" ./custom-package/DEBIAN/control
          
          # Add custom description
          sed -i '/^Description:/a \ Custom build with enhanced CRM email integration.' ./custom-package/DEBIAN/control
          sed -i '/Custom build with enhanced CRM email integration./a \ Includes automatic email-to-contact linking, enhanced mail processing,' ./custom-package/DEBIAN/control  
          sed -i '/Includes automatic email-to-contact linking, enhanced mail processing,/a \ and improved CRM integration for OnlyOffice Community Server.' ./custom-package/DEBIAN/control
        fi
        
        # Build the package
        dpkg-deb --build ./custom-package onlyoffice-communityserver-custom.deb
        
        echo "✅ Custom package created successfully"
        dpkg-deb --info onlyoffice-communityserver-custom.deb
        echo "📦 Package size: $(ls -lh onlyoffice-communityserver-custom.deb | awk '{print $5}')"
        
    - name: Upload custom package
      uses: actions/upload-artifact@v4
      with:
        name: onlyoffice-custom-${{ github.run_number }}
        path: onlyoffice-communityserver-custom.deb
        retention-days: 30

  build-docker:
    needs: create-custom-package
    runs-on: ubuntu-latest
    if: needs.create-custom-package.result == 'success'
    
    steps:
    - name: Checkout
      uses: actions/checkout@v4
    
    - name: Download custom package
      uses: actions/download-artifact@v4
      with:
        name: onlyoffice-custom-${{ github.run_number }}
        
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      
    - name: Build Docker image
      run: |
        cat > Dockerfile << 'EOF'
        FROM ubuntu:20.04
        
        ENV DEBIAN_FRONTEND=noninteractive
        
        # Install dependencies
        RUN apt-get update && \
            apt-get install -y \
            wget curl apt-transport-https ca-certificates gnupg lsb-release \
            supervisor nginx mysql-client postgresql-client && \
            rm -rf /var/lib/apt/lists/*
            
        # Install .NET runtime
        RUN wget https://packages.microsoft.com/config/ubuntu/20.04/packages-microsoft-prod.deb -O packages-microsoft-prod.deb && \
            dpkg -i packages-microsoft-prod.deb && \
            apt-get update && \
            apt-get install -y dotnet-runtime-6.0 && \
            rm packages-microsoft-prod.deb && \
            rm -rf /var/lib/apt/lists/*
        
        # Install custom OnlyOffice package  
        COPY onlyoffice-communityserver-custom.deb /tmp/
        RUN dpkg -i /tmp/onlyoffice-communityserver-custom.deb || apt-get install -f -y && \
            rm /tmp/onlyoffice-communityserver-custom.deb
        
        # Add identification labels
        LABEL org.opencontainers.image.title="OnlyOffice Community Server - Enhanced CRM Mail Integration"
        LABEL org.opencontainers.image.description="OnlyOffice with automatic email-to-contact linking and enhanced CRM integration"
        LABEL org.opencontainers.image.source="${{ github.server_url }}/${{ github.repository }}"
        LABEL org.opencontainers.image.revision="${{ github.sha }}"
        LABEL org.opencontainers.image.version="${{ env.ONLYOFFICE_VERSION }}-custom-${{ github.run_number }}"
        LABEL maintainer="Custom Build from ${{ github.repository }}"
        
        EXPOSE 80 443 5222 9865 9888
        
        HEALTHCHECK --interval=30s --timeout=10s --start-period=120s \
          CMD curl -f http://localhost/ || exit 1
          
        CMD ["/usr/bin/supervisord", "-c", "/etc/supervisor/supervisord.conf"]
        EOF
        
        docker build -t onlyoffice-custom-mail:${{ github.run_number }} .
        docker tag onlyoffice-custom-mail:${{ github.run_number }} onlyoffice-custom-mail:latest
        
        # Save the image
        docker save onlyoffice-custom-mail:latest | gzip > onlyoffice-custom-mail-image.tar.gz
        
        echo "✅ Docker image built and saved"
        echo "📦 Image size: $(ls -lh onlyoffice-custom-mail-image.tar.gz | awk '{print $5}')"
        
    - name: Upload Docker image
      uses: actions/upload-artifact@v4
      with:
        name: onlyoffice-custom-mail-image-${{ github.run_number }}
        path: onlyoffice-custom-mail-image.tar.gz
        retention-days: 7
