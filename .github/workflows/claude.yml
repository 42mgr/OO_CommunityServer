name: Build Custom OnlyOffice with Mail Module Changes

on:
  workflow_dispatch:
    inputs:
      force_rebuild:
        description: 'Force rebuild even if cached'
        type: boolean
        default: false
      skip_docker:
        description: 'Skip Docker image build'
        type: boolean
        default: false

env:
  ONLYOFFICE_VERSION: "12.7.1"  # Latest available version as of June 2025
  FORCE_REBUILD: ${{ github.event.inputs.force_rebuild || 'false' }}
  SKIP_DOCKER: ${{ github.event.inputs.skip_docker || 'false' }}
  # Alternative versions to try if main version fails
  FALLBACK_VERSIONS: "12.7.0,12.6.0,12.5.2,12.1.0,12.0.1"

jobs:
  # Fast preparation job with aggressive caching
  prepare-environment:
    runs-on: ubuntu-latest
    outputs:
      cache-hit-deb: ${{ steps.cache-deb.outputs.cache-hit }}
      cache-hit-extracted: ${{ steps.cache-extracted.outputs.cache-hit }}
      skip-build: ${{ steps.check-changes.outputs.skip-build }}
      
    steps:
    - name: Checkout code (shallow)
      uses: actions/checkout@v4
      with:
        fetch-depth: 1  # Shallow clone for speed
        submodules: false  # Skip submodules initially
        
    - name: Check for relevant changes
      id: check-changes
      run: |
        # Only check mail module files for changes
        CHANGED_FILES=$(git diff --name-only HEAD~1 2>/dev/null || echo "all")
        
        if [[ "$CHANGED_FILES" == "all" ]] || echo "$CHANGED_FILES" | grep -E "(module/ASC\.Mail|\.github/workflows)" > /dev/null; then
          echo "skip-build=false" >> $GITHUB_OUTPUT
          echo "üìù Changes detected in mail module or workflow"
        else
          echo "skip-build=true" >> $GITHUB_OUTPUT  
          echo "‚ö° No mail module changes detected"
        fi
        
    - name: Multi-level cache for DEB package
      id: cache-deb
      uses: actions/cache@v4
      with:
        path: onlyoffice-communityserver.deb
        key: onlyoffice-deb-v2-${{ env.ONLYOFFICE_VERSION }}
        restore-keys: |
          onlyoffice-deb-v2-
          onlyoffice-deb-
        
    - name: Multi-level cache for extracted package  
      id: cache-extracted
      uses: actions/cache@v4
      with:
        path: official-package/
        key: onlyoffice-extracted-v2-${{ env.ONLYOFFICE_VERSION }}-${{ hashFiles('onlyoffice-communityserver.deb') }}
        restore-keys: |
          onlyoffice-extracted-v2-${{ env.ONLYOFFICE_VERSION }}-
          onlyoffice-extracted-v2-
          
    - name: Install dependencies (parallel)
      if: steps.cache-deb.outputs.cache-hit != 'true' || steps.cache-extracted.outputs.cache-hit != 'true'
      run: |
        # Install in parallel and only what's needed
        sudo apt-get update -qq &
        wait
        sudo apt-get install -y --no-install-recommends wget curl dpkg-dev &
        wait
        
    - name: Check available OnlyOffice versions
      if: steps.cache-deb.outputs.cache-hit != 'true'
      run: |
        echo "üîç Checking available OnlyOffice versions..."
        
        # Check GitHub releases
        echo "GitHub releases:"
        curl -s "https://api.github.com/repos/ONLYOFFICE/CommunityServer/releases" | \
          jq -r '.[].tag_name' | head -5 || echo "GitHub API check failed"
        
        # Check what's available in download directory
        echo "Checking download.onlyoffice.com..."
        curl -s -I "https://download.onlyoffice.com/install/community/" || echo "Download site check failed"
        
        echo "Proceeding with configured version: ${{ env.ONLYOFFICE_VERSION }}"
        
    - name: Smart download with multiple sources
      if: steps.cache-deb.outputs.cache-hit != 'true'
      run: |
        echo "‚¨áÔ∏è Downloading OnlyOffice package..."
        
    - name: Smart download with repository method
      if: steps.cache-deb.outputs.cache-hit != 'true'
      run: |
        echo "‚¨áÔ∏è Setting up OnlyOffice repository and downloading package..."
        
        # Add OnlyOffice APT repository
        echo "üîß Adding OnlyOffice repository..."
        wget -qO - https://download.onlyoffice.com/GPG-KEY-ONLYOFFICE | sudo apt-key add -
        echo "deb https://download.onlyoffice.com/repo/debian squeeze main" | sudo tee /etc/apt/sources.list.d/onlyoffice.list
        
        # Update package lists
        sudo apt-get update -qq
        
        # Try to download the package without installing dependencies
        echo "üì¶ Downloading OnlyOffice Community Server package..."
        
        download_success=false
        
        # Method 1: Download using apt-get download
        echo "üì¶ Downloading OnlyOffice Community Server package..."
        if apt-get download onlyoffice-communityserver 2>/dev/null; then
          deb_file=$(find . -name "onlyoffice-communityserver*.deb" -type f | head -1)
          if [ -n "$deb_file" ] && [ -s "$deb_file" ]; then
            # Rename to standard name if needed
            if [ "$deb_file" != "./onlyoffice-communityserver.deb" ]; then
              mv "$deb_file" onlyoffice-communityserver.deb
            fi
            echo "‚úÖ Downloaded via apt-get download"
            download_success=true
          fi
        fi
        
        # Method 2: Use the official installation script to get package info
        if [ "$download_success" = false ]; then
          echo "üîÑ Trying installation script method..."
          
          # Download the workspace installation script
          wget -q https://download.onlyoffice.com/install/workspace-install.sh -O /tmp/workspace-install.sh
          chmod +x /tmp/workspace-install.sh
          
          # Extract the package URL from the script (if possible)
          if grep -o 'https://[^"]*onlyoffice-communityserver[^"]*\.deb' /tmp/workspace-install.sh > /tmp/package_urls.txt; then
            while IFS= read -r url; do
              echo "üîÑ Trying direct download: $url"
              if wget --timeout=60 --tries=2 "$url" -O onlyoffice-communityserver.deb 2>/dev/null; then
                if [ -f "onlyoffice-communityserver.deb" ] && [ -s "onlyoffice-communityserver.deb" ]; then
                  file_size=$(stat -c%s onlyoffice-communityserver.deb)
                  if [ "$file_size" -gt 50000000 ]; then
                    echo "‚úÖ Downloaded via script URL: $url"
                    download_success=true
                    break
                  fi
                fi
              fi
            done < /tmp/package_urls.txt
          fi
        fi
        
        # Method 3: Try alternative repository URLs
        if [ "$download_success" = false ]; then
          echo "üîÑ Trying alternative repositories..."
          
          # Try the community repository
          echo "üîÑ Trying alternative repositories..."
          echo "deb https://download.onlyoffice.com/repo/debian/community stable main" | sudo tee /etc/apt/sources.list.d/onlyoffice-community.list
          sudo apt-get update -qq
          
          if apt-get download onlyoffice-communityserver 2>/dev/null; then
            deb_file=$(find . -name "onlyoffice-communityserver*.deb" -type f | head -1)
            if [ -n "$deb_file" ] && [ -s "$deb_file" ]; then
              if [ "$deb_file" != "./onlyoffice-communityserver.deb" ]; then
                mv "$deb_file" onlyoffice-communityserver.deb
              fi
              echo "‚úÖ Downloaded from community repository"
              download_success=true
            fi
          fi
        fi
        
        # Method 4: Try building from Docker (as fallback)
        if [ "$download_success" = false ]; then
          echo "üîÑ Trying Docker extraction method..."
          
          # Install Docker if needed
          if ! command -v docker >/dev/null 2>&1; then
            curl -fsSL https://get.docker.com -o get-docker.sh
            sudo sh get-docker.sh
          fi
          
          # Pull OnlyOffice Community Server Docker image and extract package
          if sudo docker pull onlyoffice/communityserver:latest; then
            # Create container and copy package files
            container_id=$(sudo docker create onlyoffice/communityserver:latest)
            
            # Try to find and extract the DEB package from the container
            if sudo docker cp "$container_id":/app/onlyoffice/ /tmp/onlyoffice_extracted 2>/dev/null; then
              # Look for DEB files or create a pseudo-package
              echo "üì¶ Creating package from Docker container..."
              mkdir -p /tmp/docker_package/DEBIAN
              
              # Copy the application files
              sudo cp -r /tmp/onlyoffice_extracted /tmp/docker_package/opt/onlyoffice/
              
              # Create a basic control file
              cat > /tmp/docker_package/DEBIAN/control << EOF
        Package: onlyoffice-communityserver-custom
        Version: docker-extracted-$(date +%Y%m%d)
        Architecture: all
        Maintainer: Custom Build
        Description: OnlyOffice Community Server extracted from Docker
        EOF
              
              # Create the package
              sudo chown -R root:root /tmp/docker_package/
              if dpkg-deb --build /tmp/docker_package onlyoffice-communityserver.deb; then
                echo "‚úÖ Created package from Docker container"
                download_success=true
              fi
            fi
            
            sudo docker rm "$container_id" 2>/dev/null || true
          fi
        fi
        
        if [ "$download_success" = false ]; then
          echo "‚ùå All download methods failed!"
          echo "üí° OnlyOffice Community Server may need to be installed via the official script"
          echo "üí° Consider using the Docker installation method instead"
          exit 1
        fi
        
        # Final validation and info
        echo "üì¶ Final package info:"
        ls -lh onlyoffice-communityserver.deb
        dpkg-deb --info onlyoffice-communityserver.deb | head -10
        
        # If direct downloads fail, try using the custom build script if available
        if [ "$download_success" = false ] && [ -f ".github/build-scripts/download-deb.sh" ]; then
          echo "üîÑ Trying custom download script..."
          chmod +x .github/build-scripts/download-deb.sh
          if sudo ./.github/build-scripts/download-deb.sh; then
            if [ -f "onlyoffice-communityserver.deb" ] && [ -s "onlyoffice-communityserver.deb" ]; then
              echo "‚úÖ Custom script download successful!"
              download_success=true
            fi
          fi
        fi
        
        # Final fallback - try APT repository method
        if [ "$download_success" = false ]; then
          echo "üîÑ Trying APT repository method..."
          
          # Add OnlyOffice repository
          wget -qO - https://download.onlyoffice.com/repo/4.0/debian/onlyoffice.key | sudo apt-key add -
          echo "deb https://download.onlyoffice.com/repo/4.0/debian stable main" | sudo tee /etc/apt/sources.list.d/onlyoffice.list
          
          sudo apt-get update -qq
          
          # Download package without installing
          if apt-get download onlyoffice-communityserver 2>/dev/null; then
            # Find the downloaded package
            deb_file=$(find . -name "onlyoffice-communityserver*.deb" -type f | head -1)
            if [ -n "$deb_file" ] && [ -s "$deb_file" ]; then
              mv "$deb_file" onlyoffice-communityserver.deb
              echo "‚úÖ APT download successful!"
              download_success=true
            fi
          fi
        fi
        
        if [ "$download_success" = false ]; then
          echo "‚ùå All download methods failed!"
          echo "üí° Please check if OnlyOffice ${{ env.ONLYOFFICE_VERSION }} is available"
          echo "üí° You may need to update ONLYOFFICE_VERSION or provide a custom download script"
          exit 1
        fi
        
        # Final validation and info
        echo "üì¶ Final package info:"
        ls -lh onlyoffice-communityserver.deb
        dpkg-deb --info onlyoffice-communityserver.deb | head -10
        
    - name: Fast extraction (only if needed)
      if: steps.cache-extracted.outputs.cache-hit != 'true'
      run: |
        echo "üì¶ Extracting package..."
        
        # Parallel extraction
        mkdir -p official-package
        dpkg-deb -x onlyoffice-communityserver.deb official-package/ &
        dpkg-deb -e onlyoffice-communityserver.deb official-package/DEBIAN/ &
        wait
        
        # Quick validation
        extracted_files=$(find official-package -type f | wc -l)
        if [ "$extracted_files" -gt 100 ]; then
          echo "‚úÖ Extracted $extracted_files files"
        else
          echo "‚ùå Extraction appears incomplete"
          exit 1
        fi


  build-mail-module:
    needs: prepare-environment
    runs-on: windows-latest
    if: (needs.prepare-environment.outputs.skip-build != 'true' || github.event.inputs.force_rebuild == 'true') && needs.prepare-environment.result == 'success'
    
    outputs:
      build-success: ${{ steps.verify-build.outputs.success }}
      
    steps:
    - name: Checkout with submodules
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        submodules: recursive
        
    - name: Setup .NET Framework and Core
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: |
          6.0.x
          8.0.x
        
    - name: Setup MSBuild (latest)
      uses: microsoft/setup-msbuild@v2
      with:
        msbuild-architecture: x64
        
    - name: Setup NuGet (latest)
      uses: nuget/setup-nuget@v2
      with:
        nuget-version: 'latest'
        
    - name: Install Visual Studio Build Tools
      run: |
        choco install visualstudio2022buildtools --package-parameters "--add Microsoft.VisualStudio.Workload.MSBuildTools --add Microsoft.VisualStudio.Workload.WebBuildTools --quiet" --no-progress
        
    - name: Analyze solution configurations
      shell: pwsh
      run: |
        Write-Host "üîç Analyzing available solution configurations..."
        
        # Find all solution files
        $solutions = Get-ChildItem -Name "*.sln" -Recurse
        Write-Host "Found solutions:"
        $solutions | ForEach-Object { 
          Write-Host "  üìÑ $_"
          
          # Read solution file to find available configurations
          try {
            $content = Get-Content $_ -Raw
            if ($content -match 'GlobalSection\(SolutionConfigurationPlatforms\) = preSolution(.*?)EndGlobalSection') {
              $configSection = $matches[1]
              Write-Host "    Available configurations:"
              $configSection -split "`n" | ForEach-Object {
                if ($_ -match '^\s*([^=]+)\s*=\s*([^=]+)\s*$') {
                  Write-Host "      üéØ $($matches[1].Trim())"
                }
              }
            }
          } catch {
            Write-Host "    ‚ùå Cannot read solution file"
          }
        }
        
    - name: Fix project RuntimeIdentifiers
      shell: pwsh
      run: |
        Write-Host "üîß Adding RuntimeIdentifiers to projects..."
        
        # Find all csproj files that might need runtime identifiers
        $projectFiles = Get-ChildItem -Name "*.csproj" -Recurse | Where-Object {
          $_ -like "*ASC.Common*" -or $_ -like "*ASC.Mail*" -or $_ -like "*ASC.Core*"
        }
        
        foreach ($projectFile in $projectFiles) {
          Write-Host "Checking: $projectFile"
          try {
            $content = Get-Content $projectFile -Raw
            
            # Check if it's a modern SDK-style project
            if ($content -match '<Project\s+Sdk=') {
              Write-Host "  üìã Modern SDK project detected"
              
              # Add RuntimeIdentifiers if missing
              if (-not ($content -match '<RuntimeIdentifiers>')) {
                Write-Host "  üîß Adding RuntimeIdentifiers..."
                
                # Find the first PropertyGroup and add RuntimeIdentifiers
                $newContent = $content -replace '(<PropertyGroup[^>]*>)', "`$1`n    <RuntimeIdentifiers>win-x64;win-x86;win</RuntimeIdentifiers>"
                
                # Also add RuntimeIdentifier for single target
                if (-not ($newContent -match '<RuntimeIdentifier>')) {
                  $newContent = $newContent -replace '(<PropertyGroup[^>]*>)', "`$1`n    <RuntimeIdentifier>win-x64</RuntimeIdentifier>"
                }
                
                Set-Content -Path $projectFile -Value $newContent -Encoding UTF8
                Write-Host "  ‚úÖ Updated $projectFile"
              } else {
                Write-Host "  ‚úÖ RuntimeIdentifiers already present"
              }
            } else {
              Write-Host "  üìã Legacy project format"
            }
          } catch {
            Write-Host "  ‚ö†Ô∏è Error processing: $($_.Exception.Message)"
          }
        }
        
    - name: Create global MSBuild properties
      shell: pwsh
      run: |
        Write-Host "üìù Creating global MSBuild properties..."
        
        # Create Directory.Build.props in root
        $globalProps = @"
        <Project>
          <PropertyGroup>
            <Configuration Condition="`$(Configuration) == ''">Release</Configuration>
            <Platform Condition="`$(Platform) == ''">x64</Platform>
            <RuntimeIdentifier Condition="`$(RuntimeIdentifier) == ''">win-x64</RuntimeIdentifier>
            <RuntimeIdentifiers Condition="`$(RuntimeIdentifiers) == ''">win-x64;win-x86;win</RuntimeIdentifiers>
            <TreatWarningsAsErrors>false</TreatWarningsAsErrors>
            <WarningLevel>1</WarningLevel>
            <BuildProjectReferences>true</BuildProjectReferences>
            <RestoreProjectStyle>PackageReference</RestoreProjectStyle>
            <RestorePackagesWithLockFile>false</RestorePackagesWithLockFile>
            <DisableImplicitNuGetFallbackFolder>true</DisableImplicitNuGetFallbackFolder>
          </PropertyGroup>
        </Project>
        "@
        
        Set-Content -Path "Directory.Build.props" -Value $globalProps -Encoding UTF8
        Write-Host "‚úÖ Created Directory.Build.props"
        
    - name: NuGet restore with proper configuration
      shell: pwsh
      run: |
        Write-Host "üì¶ NuGet restore with runtime identifier support..."
        
        # Set environment variables for consistent restore
        $env:DOTNET_CLI_TELEMETRY_OPTOUT = "1"
        $env:DOTNET_SKIP_FIRST_TIME_EXPERIENCE = "1"
        
        # Find main solution
        $mainSolution = Get-ChildItem -Name "*.sln" | Select-Object -First 1
        
        if ($mainSolution) {
          Write-Host "Restoring solution: $mainSolution"
          
          # Try NuGet restore first
          nuget restore $mainSolution -Verbosity normal -NonInteractive -ConfigFile NuGet.Config 2>&1 | Write-Host
          
          # Then try dotnet restore with runtime
          Write-Host "`nTrying dotnet restore..."
          dotnet restore $mainSolution --runtime win-x64 --verbosity normal 2>&1 | Write-Host
          
          # Alternative restore for older packages
          Write-Host "`nTrying alternative restore..."
          dotnet restore $mainSolution --force --no-cache --verbosity normal 2>&1 | Write-Host
        }
        
    - name: Discover and use correct build configuration
      shell: pwsh
      run: |
        Write-Host "üéØ Finding correct build configurations..."
        
        $mainSolution = Get-ChildItem -Name "*.sln" | Select-Object -First 1
        
        if ($mainSolution) {
          Write-Host "Analyzing solution: $mainSolution"
          
          # Parse solution file for actual configurations
          $content = Get-Content $mainSolution -Raw
          $availableConfigs = @()
          
          if ($content -match 'GlobalSection\(SolutionConfigurationPlatforms\) = preSolution(.*?)EndGlobalSection') {
            $configSection = $matches[1]
            $configLines = $configSection -split "`n" | Where-Object { $_ -match '=' }
            
            foreach ($line in $configLines) {
              if ($line -match '^\s*([^=]+)\s*=') {
                $config = $matches[1].Trim()
                if ($config -and $config -notlike "*GlobalSection*" -and $config -notlike "*EndGlobalSection*") {
                  $availableConfigs += $config
                  Write-Host "  üìã Available: $config"
                }
              }
            }
          }
          
          # Store configurations for next step
          $availableConfigs | Out-File -FilePath "available_configs.txt" -Encoding UTF8
          
          Write-Host "`nFound $($availableConfigs.Count) configurations"
        }
        
    - name: Build with correct configuration
      shell: pwsh
      run: |
        Write-Host "üèóÔ∏è Building with discovered configurations..."
        
        $mainSolution = Get-ChildItem -Name "*.sln" | Select-Object -First 1
        $buildSuccess = $false
        
        if ($mainSolution -and (Test-Path "available_configs.txt")) {
          $availableConfigs = Get-Content "available_configs.txt"
          
          Write-Host "Trying configurations from solution file..."
          foreach ($config in $availableConfigs) {
            if ($config -match '^([^|]+)\|(.+)$') {
              $configuration = $matches[1].Trim()
              $platform = $matches[2].Trim()
              
              Write-Host "`nTrying: Configuration=$configuration, Platform=$platform"
              
              try {
                # Use exact configuration and platform from solution
                msbuild $mainSolution /p:Configuration="$configuration" /p:Platform="$platform" /verbosity:minimal /maxcpucount /p:WarningLevel=1 /p:TreatWarningsAsErrors=false
                
                if ($LASTEXITCODE -eq 0) {
                  Write-Host "‚úÖ Build successful with $configuration|$platform"
                  $buildSuccess = $true
                  break
                }
              } catch {
                Write-Host "‚ùå Build failed with $configuration|$platform"
              }
            }
          }
        }
        
        # Fallback to common configurations
        if (-not $buildSuccess) {
          Write-Host "`nüîÑ Trying common fallback configurations..."
          
          $fallbackConfigs = @(
            @{Config="Release"; Platform="x64"},
            @{Config="Debug"; Platform="x64"},
            @{Config="Release"; Platform="Any CPU"},
            @{Config="Debug"; Platform="Any CPU"},
            @{Config="Release"; Platform="AnyCPU"},
            @{Config="Debug"; Platform="AnyCPU"}
          )
          
          foreach ($fallback in $fallbackConfigs) {
            Write-Host "Trying fallback: $($fallback.Config)|$($fallback.Platform)"
            
            try {
              msbuild $mainSolution /p:Configuration="$($fallback.Config)" /p:Platform="$($fallback.Platform)" /verbosity:minimal /maxcpucount /p:WarningLevel=1
              
              if ($LASTEXITCODE -eq 0) {
                Write-Host "‚úÖ Fallback build successful!"
                $buildSuccess = $true
                break
              }
            } catch {
              Write-Host "‚ùå Fallback failed"
            }
          }
        }
        
        if (-not $buildSuccess) {
          Write-Host "‚ö†Ô∏è Full solution build failed, will try individual projects..."
        }
        
    - name: Build mail module individually
      shell: pwsh
      run: |
        Write-Host "üéØ Building mail module individually..."
        
        # Try to build mail projects specifically
        $mailProjects = @(
          "module/ASC.Mail/ASC.Mail/ASC.Mail.csproj"
        )
        
        $buildSuccess = $false
        
        foreach ($project in $mailProjects) {
          if (Test-Path $project) {
            Write-Host "`nBuilding individual project: $project"
            
            # First, try to restore this specific project
            Write-Host "Restoring project..."
            dotnet restore $project --runtime win-x64 --verbosity normal
            
            # Clean the project
            Write-Host "Cleaning project..."
            msbuild $project /t:Clean /p:Configuration=Release /p:Platform=x64 /p:RuntimeIdentifier=win-x64
            
            # Build the project with multiple attempts
            $buildConfigs = @(
              @{Config="Release"; Platform="x64"; Runtime="win-x64"},
              @{Config="Release"; Platform="AnyCPU"; Runtime="win-x64"},
              @{Config="Debug"; Platform="x64"; Runtime="win-x64"},
              @{Config="Debug"; Platform="AnyCPU"; Runtime="win-x64"}
            )
            
            foreach ($buildConfig in $buildConfigs) {
              Write-Host "Trying: $($buildConfig.Config)|$($buildConfig.Platform) with runtime $($buildConfig.Runtime)"
              
              try {
                msbuild $project /t:Build /p:Configuration="$($buildConfig.Config)" /p:Platform="$($buildConfig.Platform)" /p:RuntimeIdentifier="$($buildConfig.Runtime)" /verbosity:normal /maxcpucount /p:WarningLevel=1 /p:TreatWarningsAsErrors=false
                
                if ($LASTEXITCODE -eq 0) {
                  Write-Host "‚úÖ Individual project build successful!"
                  $buildSuccess = $true
                  break
                }
              } catch {
                Write-Host "‚ùå Build attempt failed"
              }
            }
            
            if ($buildSuccess) { break }
          }
        }
        
        # If still failing, try dependencies first
        if (-not $buildSuccess) {
          Write-Host "`nüîÑ Building dependencies first..."
          
          $dependencies = @(
            "common/ASC.Common/ASC.Common.csproj",
            "common/ASC.Core.Common/ASC.Core.Common.csproj"
          )
          
          foreach ($dep in $dependencies) {
            if (Test-Path $dep) {
              Write-Host "Building dependency: $dep"
              
              # Restore and build dependency
              dotnet restore $dep --runtime win-x64
              msbuild $dep /p:Configuration=Release /p:Platform=x64 /p:RuntimeIdentifier=win-x64 /verbosity:minimal
            }
          }
          
          # Try mail module again after dependencies
          $mailProject = "module/ASC.Mail/ASC.Mail/ASC.Mail.csproj"
          if (Test-Path $mailProject) {
            Write-Host "`nRetrying mail project after dependencies..."
            msbuild $mailProject /p:Configuration=Release /p:Platform=x64 /p:RuntimeIdentifier=win-x64 /verbosity:normal
            
            if ($LASTEXITCODE -eq 0) {
              Write-Host "‚úÖ Mail project built successfully after dependencies!"
              $buildSuccess = $true
            }
          }
        }
        
        if (-not $buildSuccess) {
          Write-Host "‚ö†Ô∏è Individual project builds also failed"
        }
        
    - name: Comprehensive build verification
      id: verify-build
      shell: pwsh
      run: |
        Write-Host "üîç Comprehensive search for ASC.Mail assemblies..."
        $success = $false
        $foundDlls = @()
        
        # Search everywhere for ASC.Mail.dll with detailed info
        try {
          $allDlls = Get-ChildItem -Path "." -Name "ASC.Mail.dll" -Recurse -ErrorAction SilentlyContinue
          
          Write-Host "Found ASC.Mail.dll files:"
          foreach ($dll in $allDlls) {
            $size = $dll.Length
            $path = $dll.FullName.Replace((Get-Location).Path, "").TrimStart('\', '/')
            
            Write-Host "  üìÑ $path ($size bytes)"
            Write-Host "      Modified: $($dll.LastWriteTime)"
            Write-Host "      Directory: $(Split-Path $path -Parent)"
            
            # Check if it's a valid assembly
            if ($size -gt 10000) {
              try {
                # Try to get assembly info without loading
                $fileInfo = [System.Diagnostics.FileVersionInfo]::GetVersionInfo($dll.FullName)
                Write-Host "      Version: $($fileInfo.FileVersion)"
                Write-Host "      ‚úÖ Valid assembly"
                
                $foundDlls += $path
                $success = $true
              } catch {
                Write-Host "      ‚ö†Ô∏è Cannot read assembly info: $($_.Exception.Message)"
                
                # Still count as found if size is reasonable
                if ($size -gt 50000) {
                  $foundDlls += $path
                  $success = $true
                  Write-Host "      ‚úÖ Added based on size"
                }
              }
            } elseif ($size -le 100) {
              Write-Host "      ‚ùå File too small (likely empty/stub)"
            } else {
              Write-Host "      ‚ö†Ô∏è Suspicious size, might be stub"
            }
          }
        } catch {
          Write-Host "Error during ASC.Mail.dll search: $($_.Exception.Message)"
        }
        
        # Search for any mail-related DLLs
        Write-Host "`nSearching for other mail-related assemblies..."
        try {
          $otherMailDlls = Get-ChildItem -Path "." -Name "*Mail*.dll" -Recurse -ErrorAction SilentlyContinue | 
            Where-Object { $_.Length -gt 1000 }
          
          foreach ($dll in $otherMailDlls) {
            $path = $dll.FullName.Replace((Get-Location).Path, "").TrimStart('\', '/')
            Write-Host "  üìÑ $path ($($dll.Length) bytes)"
          }
        } catch {
          Write-Host "Error searching for mail DLLs: $($_.Exception.Message)"
        }
        
        # Show all recently built DLLs for debugging
        Write-Host "`nAll DLL files in bin directories (by size):"
        try {
          $binDlls = Get-ChildItem -Path "." -Name "*.dll" -Recurse -ErrorAction SilentlyContinue | 
            Where-Object { $_.DirectoryName -like "*bin*" } | 
            Sort-Object Length -Descending | 
            Select-Object -First 20
            
          foreach ($dll in $binDlls) {
            $path = $dll.FullName.Replace((Get-Location).Path, "").TrimStart('\', '/')
            $sizeKB = [math]::Round($dll.Length / 1024, 1)
            Write-Host "  üìÑ $path ($sizeKB KB)"
          }
        } catch {
          Write-Host "Error listing bin DLLs: $($_.Exception.Message)"
        }
        
        # Final result
        if ($success -and $foundDlls.Count -gt 0) {
          # Use the largest DLL
          $sortedDlls = $foundDlls | ForEach-Object {
            $file = Get-Item $_
            @{Path = $_; Size = $file.Length}
          } | Sort-Object Size -Descending
          
          $mainDll = $sortedDlls[0].Path
          $mainDllSize = $sortedDlls[0].Size
          
          Write-Host "`n‚úÖ Build verification successful!"
          Write-Host "Primary DLL: $mainDll ($mainDllSize bytes)"
          
          echo "success=true" >> $env:GITHUB_OUTPUT
          echo "main_dll_path=$mainDll" >> $env:GITHUB_OUTPUT
          echo "main_dll_dir=$(Split-Path $mainDll -Parent)" >> $env:GITHUB_OUTPUT
        } else {
          Write-Host "`n‚ùå No valid ASC.Mail.dll assemblies found"
          echo "success=false" >> $env:GITHUB_OUTPUT
        }
        
    - name: Upload all build outputs for debugging
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: build-debug-${{ github.run_number }}
        path: |
          **/bin/**/*Mail*
          **/*Mail*.dll
          **/*Mail*.pdb
          **/*Mail*.exe
          available_configs.txt
          Directory.Build.props
        retention-days: 2
  # Streamlined package creation
  create-custom-package:
    needs: [prepare-environment, build-mail-module]
    runs-on: ubuntu-latest
    if: always() && (needs.prepare-environment.result == 'success' || needs.prepare-environment.result == 'skipped')
    
    steps:
    - name: Checkout code (for fallback)
      uses: actions/checkout@v4
      with:
        fetch-depth: 1
        
    - name: Check job dependencies
      run: |
        echo "=== JOB DEPENDENCY STATUS ==="
        echo "prepare-environment result: ${{ needs.prepare-environment.result }}"
        echo "build-mail-module result: ${{ needs.build-mail-module.result }}"
        echo "prepare-environment outputs:"
        echo "  cache-hit-deb: ${{ needs.prepare-environment.outputs.cache-hit-deb }}"
        echo "  cache-hit-extracted: ${{ needs.prepare-environment.outputs.cache-hit-extracted }}"
        echo "  skip-build: ${{ needs.prepare-environment.outputs.skip-build }}"
        
    - name: Try to restore cached package
      id: restore-cache
      uses: actions/cache/restore@v4
      with:
        path: |
          onlyoffice-communityserver.deb
          official-package/
        key: onlyoffice-extracted-v2-${{ env.ONLYOFFICE_VERSION }}-${{ hashFiles('onlyoffice-communityserver.deb') }}
        restore-keys: |
          onlyoffice-extracted-v2-${{ env.ONLYOFFICE_VERSION }}-
          onlyoffice-extracted-v2-
          
    - name: Download artifacts from preparation job (fallback)
      if: steps.restore-cache.outputs.cache-hit != 'true'
      uses: actions/download-artifact@v4
      continue-on-error: true
      with:
        name: extracted-onlyoffice-package
        
    - name: Verify package availability
      run: |
        echo "üîç Checking package availability..."
        
        if [ -d "official-package" ] && [ -f "onlyoffice-communityserver.deb" ]; then
          echo "‚úÖ Package available from cache/artifacts"
          echo "üì¶ DEB size: $(ls -lh onlyoffice-communityserver.deb | awk '{print $5}')"
          echo "üìÅ Extracted files: $(find official-package -type f | wc -l)"
        else
          echo "‚ùå Package not available, need to download and extract"
          
          # Emergency download if nothing is available
          echo "üö® Emergency package download..."
          
          # Install dependencies
          sudo apt-get update -qq
          sudo apt-get install -y --no-install-recommends wget dpkg-dev apt-transport-https ca-certificates
          
          # Add OnlyOffice APT repository
          echo "üîß Adding OnlyOffice repository..."
          wget -qO - https://download.onlyoffice.com/GPG-KEY-ONLYOFFICE | sudo apt-key add -
          echo "deb https://download.onlyoffice.com/repo/debian squeeze main" | sudo tee /etc/apt/sources.list.d/onlyoffice.list
          
          # Update package lists
          sudo apt-get update -qq
          
          download_success=false
          
          # Try to download the package using apt-get download
          echo "üì¶ Downloading OnlyOffice Community Server..."
          
          # Download to current directory instead of /tmp
          if apt-get download onlyoffice-communityserver 2>/dev/null; then
            deb_file=$(find . -name "onlyoffice-communityserver*.deb" -type f | head -1)
            if [ -n "$deb_file" ] && [ -s "$deb_file" ]; then
              # Rename to standard name if needed
              if [ "$deb_file" != "./onlyoffice-communityserver.deb" ]; then
                mv "$deb_file" onlyoffice-communityserver.deb
              fi
              echo "‚úÖ Emergency download successful!"
              download_success=true
            fi
          fi
          
          # Fallback: Try alternative repository
          if [ "$download_success" = false ]; then
            echo "üîÑ Trying alternative repository..."
            echo "deb https://download.onlyoffice.com/repo/debian/community stable main" | sudo tee /etc/apt/sources.list.d/onlyoffice-community.list
            sudo apt-get update -qq
            
            if apt-get download onlyoffice-communityserver 2>/dev/null; then
              deb_file=$(find . -name "onlyoffice-communityserver*.deb" -type f | head -1)
              if [ -n "$deb_file" ] && [ -s "$deb_file" ]; then
                if [ "$deb_file" != "./onlyoffice-communityserver.deb" ]; then
                  mv "$deb_file" onlyoffice-communityserver.deb
                fi
                echo "‚úÖ Alternative repository download successful!"
                download_success=true
              fi
            fi
          fi
          
          if [ "$download_success" = false ]; then
            echo "‚ùå Emergency download failed"
            exit 1
          fi
          
          # Extract the package
          echo "üì¶ Emergency extraction..."
          mkdir -p official-package
          dpkg-deb -x onlyoffice-communityserver.deb official-package/
          dpkg-deb -e onlyoffice-communityserver.deb official-package/DEBIAN/
          
          echo "‚úÖ Emergency package preparation complete"
        fi
        
    - name: Download build artifacts (conditional)
      if: needs.build-mail-module.outputs.build-success == 'true'
      uses: actions/download-artifact@v4
      continue-on-error: true
      with:
        name: mail-module-build
        path: build-output/
        
    - name: Fast package creation
      run: |
        echo "üöÄ Fast package creation..."
        
        # Verify we have the source package
        if [ ! -d "official-package" ]; then
          echo "‚ùå official-package directory still not found!"
          echo "Available directories:"
          ls -la
          exit 1
        fi
        
        # Quick copy
        echo "üìã Copying package structure..."
        cp -r official-package custom-package
        
        echo "‚úÖ Package structure copied"
        echo "üìä Files in custom package: $(find custom-package -type f | wc -l)"
        
        # Replace mail module if we have a new one  
        if [ -d "build-output/" ]; then
          echo "üìã Searching for built mail assemblies..."
          
          # Find any ASC.Mail.dll files in the build output
          mail_dlls=$(find build-output -name "ASC.Mail.dll" -type f 2>/dev/null || true)
          
          if [ -n "$mail_dlls" ]; then
            echo "‚úÖ Found compiled mail assemblies:"
            echo "$mail_dlls"
            
            # Get the largest DLL file (most likely the main one)
            main_dll=$(echo "$mail_dlls" | xargs ls -la | sort -k5 -nr | head -1 | awk '{print $NF}')
            echo "üìã Using primary DLL: $main_dll"
            
            # Find all ASC.Mail.dll locations in the package and replace them
            package_dlls=$(find custom-package -name "ASC.Mail.dll" -type f 2>/dev/null || true)
            
            if [ -n "$package_dlls" ]; then
              echo "üîÑ Replacing mail assemblies in package:"
              while IFS= read -r dll_path; do
                if [ -f "$dll_path" ]; then
                  cp "$main_dll" "$dll_path"
                  echo "  ‚úÖ Updated: $dll_path"
                fi
              done <<< "$package_dlls"
              
              # Also copy any related files (PDB, XML, etc.)
              main_dll_dir=$(dirname "$main_dll")
              for ext in pdb xml exe.config; do
                if [ -f "${main_dll_dir}/ASC.Mail.$ext" ]; then
                  while IFS= read -r dll_path; do
                    base_path="${dll_path%.dll}.$ext"
                    base_dir=$(dirname "$dll_path")
                    if [ -f "$base_path" ] || [ -d "$base_dir" ]; then
                      cp "${main_dll_dir}/ASC.Mail.$ext" "$base_dir/" 2>/dev/null || true
                      echo "  ‚úÖ Updated: ASC.Mail.$ext in $base_dir"
                    fi
                  done <<< "$package_dlls"
                fi
              done
              
            else
              echo "‚ö†Ô∏è No ASC.Mail.dll files found in package to replace"
              # Create a new directory for the compiled assemblies
              mkdir -p custom-package/opt/onlyoffice/CommunityServer/bin/
              echo "$mail_dlls" | while read -r dll; do
                if [ -f "$dll" ]; then
                  cp "$dll" custom-package/opt/onlyoffice/CommunityServer/bin/
                  echo "  ‚úÖ Added: $(basename "$dll") to package"
                fi
              done
            fi
            
          else
            echo "‚ÑπÔ∏è No ASC.Mail.dll found in build output, using original mail module"
            echo "Available files in build-output:"
            find build-output -name "*.dll" -type f | head -10 || echo "No DLL files found"
          fi
        else
          echo "‚ÑπÔ∏è No build output available, using original mail module"
        fi
        
        # Comprehensive permission fix
        if [ -d "custom-package/DEBIAN" ]; then
          echo "üîß Fixing DEBIAN script permissions..."
          
          # Make all maintainer scripts executable (must be >=0555 and <=0775)
          for script in preinst postinst prerm postrm config templates; do
            if [ -f "custom-package/DEBIAN/$script" ]; then
              chmod 755 "custom-package/DEBIAN/$script"
              echo "‚úÖ Fixed $script: $(ls -la custom-package/DEBIAN/$script | awk '{print $1}')"
            fi
          done
          
          # Control and conffiles should be readable only
          chmod 644 custom-package/DEBIAN/control 2>/dev/null || true
          chmod 644 custom-package/DEBIAN/conffiles 2>/dev/null || true
          chmod 644 custom-package/DEBIAN/md5sums 2>/dev/null || true
          
          echo "üìã Final DEBIAN permissions:"
          ls -la custom-package/DEBIAN/ | head -5
        fi
        
        # Quick metadata update
        if [ -f "custom-package/DEBIAN/control" ]; then
          sed -i "s/Package: onlyoffice-communityserver/Package: onlyoffice-communityserver-custom/" custom-package/DEBIAN/control
          sed -i "s/Version: \(.*\)/Version: \1-custom-${{ github.run_number }}/" custom-package/DEBIAN/control
        fi
        
        # Validate package structure before building
        echo "üîç Validating package structure..."
        
        if [ ! -d "custom-package" ]; then
          echo "‚ùå Custom package directory not found!"
          exit 1
        fi
        
        if [ ! -d "custom-package/DEBIAN" ]; then
          echo "‚ùå DEBIAN directory not found!"
          exit 1
        fi
        
        if [ ! -f "custom-package/DEBIAN/control" ]; then
          echo "‚ùå Control file not found!"
          exit 1
        fi
        
        echo "‚úÖ Package structure validated"
        echo "üìä Total files: $(find custom-package -type f | wc -l)"
        echo "üì¶ Package size: $(du -sh custom-package | cut -f1)"
        
        # Build package with better error handling
        echo "üî® Building DEB package..."
        
        sudo chown -R root:root custom-package/
        
        if dpkg-deb --build custom-package onlyoffice-communityserver-custom.deb 2>&1; then
          echo "‚úÖ Package built successfully!"
          
          # Validate the final package
          if [ -f "onlyoffice-communityserver-custom.deb" ] && [ -s "onlyoffice-communityserver-custom.deb" ]; then
            echo "üì¶ Final package size: $(ls -lh onlyoffice-communityserver-custom.deb | awk '{print $5}')"
            
            # Quick package validation
            echo "üîç Validating package integrity..."
            if dpkg-deb --info onlyoffice-communityserver-custom.deb >/dev/null 2>&1; then
              echo "‚úÖ Package validation passed!"
            else
              echo "‚ö†Ô∏è Package validation warnings (may still be usable)"
            fi
          else
            echo "‚ùå Package file is missing or empty"
            exit 1
          fi
        else
          echo "‚ùå Package build failed!"
          echo "üìã DEBIAN directory final state:"
          ls -la custom-package/DEBIAN/
          exit 1
        fi
        
    - name: Upload custom package
      uses: actions/upload-artifact@v4
      with:
        name: onlyoffice-custom-${{ github.run_number }}
        path: onlyoffice-communityserver-custom.deb
        retention-days: 7  # Reduced retention

  # Optional Docker build
  build-docker:
    needs: create-custom-package
    runs-on: ubuntu-latest
    if: needs.create-custom-package.result == 'success' && github.event.inputs.skip_docker != 'true'
    
    steps:
    - name: Download custom package
      uses: actions/download-artifact@v4
      with:
        name: onlyoffice-custom-${{ github.run_number }}
        
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      
    - name: Fast Docker build
      run: |
        # Streamlined Dockerfile
        cat > Dockerfile << 'EOF'
        FROM ubuntu:20.04
        ENV DEBIAN_FRONTEND=noninteractive
        
        # Essential packages only
        RUN apt-get update && apt-get install -y --no-install-recommends \
            wget curl supervisor nginx && \
            rm -rf /var/lib/apt/lists/*
            
        # Install custom package
        COPY onlyoffice-communityserver-custom.deb /tmp/
        RUN dpkg -i /tmp/onlyoffice-communityserver-custom.deb || apt-get install -f -y && \
            rm /tmp/onlyoffice-communityserver-custom.deb
        
        LABEL version="${{ env.ONLYOFFICE_VERSION }}-custom-${{ github.run_number }}"
        EXPOSE 80 443
        CMD ["/usr/bin/supervisord", "-c", "/etc/supervisor/supervisord.conf"]
        EOF
        
        # Build with BuildKit for speed
        DOCKER_BUILDKIT=1 docker build --progress=plain -t onlyoffice-custom-mail:latest .
        
        # Compress and save
        docker save onlyoffice-custom-mail:latest | gzip -1 > onlyoffice-custom-mail-image.tar.gz
        
        echo "üì¶ Image size: $(ls -lh onlyoffice-custom-mail-image.tar.gz | awk '{print $5}')"
        
    - name: Upload Docker image
      uses: actions/upload-artifact@v4
      with:
        name: onlyoffice-docker-${{ github.run_number }}
        path: onlyoffice-custom-mail-image.tar.gz
        retention-days: 3
